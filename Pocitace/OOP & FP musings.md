I've been given a fair FP background in college, several of my professors were quite the FP enthusiasts and I quickly developed a liking to it myself. I've gone through several (some of them quite in-depth) FP courses, taught in context on different languages - scheme, lisp, haskell. I also experimented with clojure and elm later on. So I definitely do have some understanding of the paradigm.

On the other hand I have quite a lot of experience with OOP languages both in school and after it (I've been a full-time software dev since around 2009) and I've always argued that these two paradigms aren't nearly as exclusive as lots of people tend to claim. For me, the most fundamental things in FP are pure functions (and their composition) and immutability and the most fundamental things in OOP are objects (attributes + behavior + encapsulation) and their interaction (method calls as message passing).

Objects are nice because they are such a natural model to (most) human minds - it's what we've been seeing all around us our whole lives - things have attributes (cat has four legs) and behavior (dog barks). Pure functions (and their pipelines) and immutability are great because they make the evaluation of our programs predictable and understandable - data goes in on one side, out on the other. And if there is no mutation, you don't have to wander, which part of your program changed some state at the other side of your code-base.

Yes, most OOP languages also have inheritance (in so many flavours) and other fancy stuff and they are definitely useful from time to time, but noone's forcing you to use them everywhere and I don't think you should. And yes, some (especially the more academic) FP languages have things like (applicative) functors, monads, etc., but I'd say you can go for years writing pretty nice, functional code without understanding any of these. And lastly, I never really understood why mutation should be one of the cornerstones of OOP! There's nothing OOP-specific to mutation. You can have a language that has mutable (even global) state without having any objects whatsoever and you could easily make an object-oriented language with very limited (or even none at all) mutation, although this is rarely done in practice. For me, mutation is something you do if you really can't help it (sometimes for performance reasons), or in those few cases when it's just damn practical that it outweighs the negatives.

Also, you must have some "impure" effects somewhere in most (even FP) programs (especially in long-running ones like web apps), otherwise it won't do much except exercise your CPU, although it's really nice if your language does enforce a strict boundary BTW pure and impure code as e.g. Haskell does, but it might make the code a bit more convoluted (at least until you get used to the way IO is done there).

Most modern laguages allow you to combine these two (and probably other) paradigms quite nicely. I've been doing this in ruby, python and most recently kotlin for years and I've been pretty happy with this combination. You can use objects as building blocks of your program's domain and pass these through pipelines of pure functions (or method chains which (if pure) are the same thing, but read more nicely, unless you have the pipe operator in your lang of choice). Most languages have ready-made (often even standard) libraries providing dozens of those functions we funct. programmers have grown to love - map, filter, reduce, yeah, you know. Kotlin's std lib is a great example of this which might seem all the more surprising as it's often being sold as the "modern Java cousin", Java being 1) one of the most proliferate example of OOP langs and 2) extremely terrible at having pure functions in std lib (more of this later?). Unless you're instantiating really a lot and concerned about performance, you can create new copies of your objects with updated attributes instead of mutating existing ones (and kotlin again makes this really simple with its data classes). And it's not that hard to do some variation of this "functional core, imperative shell" kind of architecture (yes, there are a lot), although it does take a bit of practice.
