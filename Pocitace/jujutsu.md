## Commands
#### change management
- `jj new`- creates a new change, empty and "undescribed" by default
	- `-m "message"` set the starting message
	- `-B <rev>` create the change before `<rev>`
	- `-A <rev>` create the change after `<rev>`
	- `--no-edit` don't switch `@` to the new change
	- can take one or more parent rev-sets
		- if the parent already has a child, this will create a branching
	- when more than one parent is specified, it creates a merge change
- `jj describe`- describes a change, by default opens editor to write the message
	- `-m "message"` set the message directly
- `jj edit <rev>` - switch (move `@`) to `<rev>` to continue editing it
- `jj next` - switch (move `@`) to child change
	- by default, makes a `new` change on top of it
	- `--edit` don't make a new change - continue editing the existing one
- `jj prev` - switch (move `@`) to parent change
- `jj abandon` - abandon (drop) a change
- `jj squash`- move changes from current change into the parent one (by default)
	- by default, moves all changes
	- can take file(set)s
	- `-i` interactive
	- default (no rev-set specified) is equal to `-r @` or `--from @ --into @-`
- `jj split` - split a revision in two
	- this is nice, but can be really confusing
	- if you specify paths, those will appear in the **new** revision
	- it opens editor twice to enter a message, first is for the **new** revision, second  is for the **old** one
- `jj rebase` - rebase a change onto a new parent
	- `-s <rev>` (`--revisions`) - what to rebase - will detach (and re-attach) it and its descendants - typical usage
	- `-r <rev>` (`--revisions`) - what to rebase - will rebase a single rev, while its descendants will be rebased onto its parent
	- `-d <rev>` (`--destination`) - what to rebase onto
- `jj resolve` - resolve rebase/merge conflicts
- `jj restore` - restore files from other revs - similar to `git checkout` with file path
- `jj revert` - apply the reverse of the given revision(s)
- `jj undo` -  undo the last command
- `jj redo` -  redo the last undo
- `jj bookmark` - work with bookmarks (named branches)
	- subcommands: `list`, `create`, `move`, `set`, `rename`, `forget`, `delete`, `track`, `untrack`
		- `create` - create a bookmark (named branch)
		- `set <names>` - update bookmark(s)
			- by default, sets them to point to `@`, but we can specify `-r <rev>`
- `jj git remote` - work with git remotes
	- subcommands: `list`, `add`, `rename`, `remove`
- `jj git push` - push changes to git remote
	- `-b <bookmark>` push only this bookmark
	- `--all` all bookmarks
	- `-c <rev>` push this change by creating a bookmark
- `jj git fetch` - fetch changes from git remote
#### informative
- `jj status` - shows repo status
	- `--no-pager`
- `jj show` - show details of revision
- `jj log` - prints the change log
	- `-r` - which revisions to show, e.g.:
		- `jj log -r 'heads(all())'` will print all heads
	- `--limit n`
- `jj op log` - shows a log of all operations
	- this is useful when making more edits without creating a new change
#### configuration
- `jj git init`
	- initializes a new repo with git as storage
	- `--colocate` - use existing git repo - git commands can be used alongside `jj`
- `jj config`
	- get/set config options

## Rev-sets
- most commands take optional `-r <revset>` param, which defaults to `@`
- rev-sets can be
	- a symbol:
		- commit IDs - hex digits
		- change IDs - only letters g..z - never collide with commit ID
			- any unique prefix of ID can be used
		- `@` - current working change
	- an operator applied to other rev-sets
		- `<rev>-` - parent of `<rev>` (which one?)
		- `<rev>+` - child of `<rev>` (which one?)
		- `x & y` - changes that are in both `x` and `y` (an intersection)
		- `x | y` - changes in either (a union)
		- `::x` - ancestors of `x`
		- `x::` - descendants of `x`
		- ...
	- a function application
		- `root()` - the root change
		- `trunk()` - looks for a remote named `origin` or `upstream`, and looks for a `main`, `master`, or `trunk` branch, and then provides that. since we don't have any of those right now, it gives us the same as `root()`
		- `all()` - all visible (?) changes
		- `mine()` - all changes authored by current user
		- `parents(x)`
		- `ancestors(x)` - same as `::x`
		- `ancestors(x, depth)`
		- `heads(x)` - commits in `x` that are not ancestors of other commits in `x`
		- `description(x)`: commits that have `x` in their description
		- ...
	- more complex expressions composed of the previous:
		- `jj log -r 'author("Steve Klabnik") & description(print)'`
		- `jj log -r '@ | ancestors(remote_bookmarks().., 2) | trunk()'`