### Main concepts and how to implement them
- `Entity` - a structure with slot metadata
	- there are basically two "structures" here:
		- the "instance" of the entity, holding actual values of the slots (+ id)
		- the "class" of the entity, holding the slot metadata
	- we'll probably represent "class" as a module with a nullary function returning the list of all slots and another function to get the slot metadata by it's name, and the instance as a `Struct` of this module
- `EntityStorage` (manager class in `qwazar`) - knows how entities are stored in the given type of persistence backend (e.g. db, file, JSON API, etc.)
	- this will probably be a module implementing a `@behaviour`
- `EntityStore` (manager instance in `qwazar`) - a specific "instance" of the storage for a specific entity type.
	- this will probably be a struct holding the storage module + data needed to work with it
	- for example, if the storage is implemented as an `Agent`, the store will hold the `pid` of the `Agent` process
	- there are actually three "things" (I'd say "entities" here, but this would be easy to confuse with `Entity` above) here
		- the behavior module above
		- the "thing" that actually stores the data (which changes in time - mutable state) and a "handle" to communicate with it
			- this can be either "external" (e.g. db, file), in which case the "handle" will be a db connection, a file or filename (depending on whether we want to keep it open), etc.
			- or it can be "internal", typically a process holding the state (an `Agent`, `GenServer`, etc.), in which case the "handle" will be a `pid`
- `Repository`
	- a registry of entity stores, probably in a process (`Agent`)
	- if we have just one implementation, we can have a single `Repository` module and a `pid` to the storing process (or maybe even register the process under a global name)
	- if we have more than one implementation, then we need a similar pattern as above - behavior module + handle to the storing process / etc table or whatever
- `View`
	- probably just a function taking some predefined params
	- each view may live in a separate module, if we don't need to reuse any helper functions, or several views can share one module, if we do
	- if we wanted to make the contract more formalized, we could use a behavior module instead of a simple function, in this case, we have two options:
		- one view per module - then the callback function doesn't need to take the view name
		- more views per module - then it does, but then this is basically a `ViewSet`
- `ViewSet` - "something" representing a set of related `View`s
	- this could either be just a map `%{view_name: View}` (where `View` is either a function, or a behavior module)
	- or the `ViewSet` itself could be a behavior module, implementing `views()` and `render(view, params, context)`
- `ViewSetRegistry`
	- a registry of `ViewSet`s
	- similar design as `Repository` above
### Main flow
- Elizar would be a web application, so the entry-point will be a request
- the main type of request (especially if the app is backend-rendered, so we don't need to make FE->BE requests for actions and data retrieval), will be a "get view" request
### "Get view" request
- the `ViewSet` controller (or something similar - maybe a `LiveView`) will receive a request to render `{viewset_id, view_id}` with given `params`
- the controller will retrieve the `ViewSet` from `ViewSetRegistry` and depending on the considerations above, it will either
	- call `render(view_id, params, context)` on it
	- retrieve a view from it and call `render(params, context)` if `View` is a module
	- retrieve a view f