### Main concepts and how to implement them
- `Entity` - a structure with slot metadata
	- there are basically two "structures" here:
		- the "instance" of the entity, holding actual values of the slots (+ id)
		- the "class" of the entity, holding the slot metadata
	- we'll probably represent "class" as a module with a nullary function returning the list of all slots and another function to get the slot metadata by it's name, and the instance as a `Struct` of this module
- `EntityStorage` (manager class in `qwazar`) - knows how entities are stored in the given type of persistence backend (e.g. db, file, JSON API, etc.)
	- this will probably be a module implementing a `@behaviour`
- `EntityStore` (manager instance in `qwazar`) - a specific "instance" of the storage for a specific entity type.
	- this will probably be a struct holding the storage module + data needed to work with it
	- for example, if the storage is implemented as an `Agent`, the store will hold the `pid` of the `Agent` process
	- there are actually three "things" (I'd say "entities" here, but this would be easy to confuse with `Entity` above) here
		- the behavior module above
		- the "thing" that actually stores the data (which changes in time - mutable state) and a "handle" to communicate with it
			- this can be either "external" (e.g. db, file), in which case the "handle" will be a db connection, a file or filename (depending on whether we want to keep it open), etc.
			- or it can be "internal", typically a process holding the state (an `Agent`, `GenServer`, etc.), in which case the "handle" will be a `pid` (actually the external handles will often be pids too since they are typically worked with through some managing process)
- `Repository`
	- a registry of entity stores, probably in a process (`Agent`)
	- if we have just one implementation, we can have a single `Repository` module and a `pid` to the storing process (or maybe even register the process under a global name)
	- if we have more than one implementation, then we need a similar pattern as above - behavior module + handle to the storing process / etc table or whatever
- `View`
	- probably just a function taking some predefined params
	- each view may live in a separate module, if we don't need to reuse any helper functions, or several views can share one module, if we do
	- if we wanted to make the contract more formalized, we could use a behavior module instead of a simple function, in this case, we have two options:
		- one view per module - then the callback function doesn't need to take the view name
		- more views per module - then it does, but then this is basically a `ViewSet`
- `ViewSet` - "something" representing a set of related `View`s
	- this could either be just a map `%{view_name: View}` (where `View` is either a function, or a behavior module)
	- or the `ViewSet` itself could be a behavior module, implementing `views()` and `render(view, params, context)`
- `ViewSetRegistry`
	- a registry of `ViewSet`s
	- similar design as `Repository` above
### Main flow
- Elizar would be a web application, so the entry-point will be a request
- the main type of request (especially if the app is backend-rendered, so we don't need to make FE->BE requests for actions and data retrieval), will be a "get view" request
#### "Render view" request
- the `ViewSet` controller (or something similar - maybe a `LiveView`) will receive a request to render `{viewset_id, view_id}` with given `params`
- the controller will retrieve the `ViewSet` from `ViewSetRegistry` and depending on the considerations above, it will either
	- call `render(view_id, params, context)` on it
	- retrieve a view from it and call `render(params, context)` if `View` is a module
	- retrieve a view from it and call it with `(params, context)` if `View` is a function
### View rendering
- how will the rendering work? what will the `View` rendering functions return?
- this is one of the main decisions that need to be made early enough
- there are two main options here:
	- the `render` functions will be pure and will return "something to be rendered" - either an `HTML` directly (probably rendered by calling some lower-level phoenix rendering logic), or some data structure, which will then be converted into `HTML` (or something else)
		- the advantage of this is that we could use the same tools to render other kinds of output, e.g. Word, PDF, etc.
		- another advantage of this approach is that the `View`s (written by less technical staff) would use a more high-level DSLs to build the pages and didn't need to interact with lower-level stuff like HEEX templates and phoenix components
			- not sure how interactive stuff like forms and data-tables would work in this case though
	- we will want to take advantage of `LiveView` (which would be really nice, because this allows for much more interactive experience), but then the `View`s can no longer be/provide simple pure functions, instead they will probably be `LiveComponents`
		- in this case, we'd loose the re-usability of the `View`s for document generation, but gained the interactivity
		- in this case, the "render view" handler would be a `LiveView` instead of a `Controller`
### First steps
- we should probably start with the "`View`s as pure functions" model, because it will be much simpler (especially without pre-existing knowledge of `LiveView`) and allow as to try out the rest of the architecture without getting mired up in the `LiveView` (and phoenix in general)
- how would we start then?
	- create a phoenix app, add minimal configuration if needed
	- add the main "render view" route - something like `GET /render/viewset_id/view_id`
	- add controller for it
	- add simplest implementation of `View`, `ViewSet` and `ViewSetRegistry`
	- add a simple `View`, without any data retrieval
	- retrieve view in the `ViewController`
	- add simplest implementation of `Entity`, `EntityStorage` and `Repository`
	- add a simple, specific `Entity` and `EntityStore`
	- add a `View` utilizing these
- then we can
	- refactor and reorganize the above, until it feels right
	- play with existing parts of the architecture
	- add different implementations (db entities, EA entities, JSON API entities)
	- start adding more complex stuff, like forms, dependent inputs, bg jobs, reports, etc.
	- see how far we can take the "views as pure functions" approach - are they interactive enough? where are they lacking? can we solve it or do we need `LiveView`s?
	- if needed, switch to `LiveView`s
### Prerequisites
- should we just start, or study first?
	- I think I more or less grasp the basic Elixir concepts
	- maybe go over the getting started and OTP guides to see if I missed something
	- probably should go over the phoenix guides, if/when we decide to switch to `LiveView`s, go over `LiveView` guides
	- it would be nice to read "Elixir in action" first, but then I may never start
		- currently read up-to chapter 7.3, but a long time ago - will have to skim it again
	- it would be even nicer to also read the "Programming Phoenix" and "Programming Phoenix LiveView", but 1) ditto and 2) "programming phoenix" is pretty outdated