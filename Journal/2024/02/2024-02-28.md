```kotlin
@Suppress("FunctionName")
fun <
    QueryBeanType : TQRootBean<*, QueryBeanType>,
    QueryPropertyType : PString<QueryBeanType>,
    > QueryBeanType.with_(
    propertySelector: QueryBeanType.() -> QueryPropertyType,
    matcher: FilterMatcher,
    value: String?,
    // slotType: SlotType,
    castType: ScalarType,
    // to find all available cast types, see usages of
    // io.ebeaninternal.server.type.DefaultTypeManager.addType()
    nullValues: Collection<String> = emptyList(),
    platform: Platform = Platform.GENERIC,
): QueryBeanType {
    handleNull(propertySelector, matcher, value, nullValues)?.let { return it }

    value as String
    // val scalarType = scalarTypeFor(slotType)
    val dbTypeName = dbTypeNameFor(castType)
    val castProperty = propertySelector().cast(castType, platform)
    val castParam = "?".cast(dbTypeName, platform)

    // in H2, this works even without casting the value
    // in postgres, the value must also be cast, but this doesn't work, because it results in
    // where prop::DATE > '2000-01-01::DATE'
    // so the cast is inside the string value
    // val castValue = value!!.cast(dbTypeName)

    return apply {
        when (matcher) {
            // FilterMatcher.EQ -> expressionList.eq(castProperty, castValue)
            // FilterMatcher.NEQ -> expressionList.ne(castProperty, castValue)
            FilterMatcher.IEQ -> expressionList.ieq(castProperty, value)
            FilterMatcher.INEQ -> not().expressionList.ieq(castProperty, value).endNot()
            FilterMatcher.CONTAINS -> expressionList.contains(castProperty, value)
            FilterMatcher.NCONTAINS -> not().expressionList.contains(castProperty, value).endNot()
            FilterMatcher.ICONTAINS -> expressionList.icontains(castProperty, value)
            FilterMatcher.INCONTAINS -> not().expressionList.icontains(castProperty, value).endNot()
            FilterMatcher.LIKE -> expressionList.like(castProperty, value)
            FilterMatcher.NLIKE -> not().expressionList.like(castProperty, value).endNot()
            FilterMatcher.ILIKE -> expressionList.ilike(castProperty, value)
            FilterMatcher.INLIKE -> not().expressionList.ilike(castProperty, value).endNot()
            //
            // // these will work, but will use string comparison (alphabetical ordering)
            // FilterMatcher.LT -> expressionList.lt(castProperty, castValue)
            // FilterMatcher.GT -> expressionList.gt(castProperty, castValue)
            // FilterMatcher.LTE -> expressionList.le(castProperty, castValue)
            // FilterMatcher.GTE -> expressionList.ge(castProperty, castValue)

            FilterMatcher.EQ -> raw("$castProperty = $castParam", value)
            FilterMatcher.NEQ -> raw("$castProperty != $castParam", value)
            // FilterMatcher.IEQ -> raw("$castProperty = ?::$dbTypeName", value)
            // FilterMatcher.INEQ -> not().raw("$castProperty = ?::$dbTypeName", value).endNot()
            // FilterMatcher.CONTAINS -> raw("$castProperty = ?::$dbTypeName", value)
            // FilterMatcher.NCONTAINS -> not().raw("$castProperty = ?::$dbTypeName", value).endNot()
            // FilterMatcher.ICONTAINS -> raw("$castProperty = ?::$dbTypeName", value)
            // FilterMatcher.INCONTAINS -> not().raw("$castProperty = ?::$dbTypeName", value).endNot()
            // FilterMatcher.LIKE -> raw("$castProperty = ?::$dbTypeName", value)
            // FilterMatcher.NLIKE -> not().raw("$castProperty = ?::$dbTypeName", value).endNot()
            // FilterMatcher.ILIKE -> raw("$castProperty = ?::$dbTypeName", value)
            // FilterMatcher.INLIKE -> not().raw("$castProperty = ?::$dbTypeName", value).endNot()

            // these will work, but will use string comparison (alphabetical ordering)
            FilterMatcher.LT -> raw("$castProperty < $castParam", value)
            FilterMatcher.GT -> raw("$castProperty > $castParam", value)
            FilterMatcher.LTE -> raw("$castProperty <= $castParam", value)
            FilterMatcher.GTE -> raw("$castProperty >= $castParam", value)

            // else -> throw UnsupportedMatcher(matcher, "string value")
        }
    }
}

// inline fun <reified T : Any> Query.Property<*>.cast() = cast(T::class)

fun String.cast(castTo: ScalarType, platform: Platform = Platform.GENERIC) =
    cast(dbTypeNameFor(castTo), platform)
fun Query.Property<*>.cast(castTo: ScalarType, platform: Platform = Platform.GENERIC) =
    cast(dbTypeNameFor(castTo), platform)

// fun <T> Query.Property<*>.cast(castTo: Class<T>) = cast<T>(castTo.simpleName)

fun Query.Property<*>.cast(dbTypeName: String, platform: Platform = Platform.GENERIC) =
    // Query.Property.of<T>("$this::$dbTypeName")
    toString().cast(dbTypeName, platform)

// fun String.cast(dbTypeName: String) = "$this::$dbTypeName"
fun String.cast(dbTypeName: String, platform: Platform = Platform.GENERIC) =
    if (platform in SQL_SERVER_PLATFORMS) "CONVERT($dbTypeName, $this, 23)"
    else "CAST($this AS $dbTypeName)"

// only this variant works in MS SQL when ISO dates are used
// - the problem is, we don't have access to the database here
// fun String.cast(dbTypeName: String) = "CONVERT($dbTypeName, $this, 23)"

fun scalarTypeFor(slotType: SlotType) = when (slotType) {
    SlotType.Int -> ScalarType.Integer // tested in H2
    SlotType.Date -> ScalarType.Date // tested in H2
    SlotType.DateTime -> ScalarType.DateTime // tested in H2
    SlotType.Float -> ScalarType.Float // tested in H2
    SlotType.Decimal -> ScalarType.Decimal // tested in H2
    SlotType.Boolean -> ScalarType.Boolean // tested in H2
    SlotType.String -> ScalarType.String // tested in H2
    SlotType.StringList -> TODO()
    SlotType.Entity -> TODO()
    SlotType.EntityList -> TODO()
    SlotType.Connection -> TODO()
    SlotType.ConnectionList -> TODO()
    SlotType.Lazy -> TODO()
}

enum class ScalarType {
    Integer, Decimal, Float, String, Boolean, Date, DateTime,
}

fun dbTypeNameFor(scalarType: ScalarType) = when (scalarType) {
    ScalarType.Float -> "FLOAT"
    ScalarType.Integer -> "INTEGER"
    ScalarType.Decimal -> "DECIMAL"
    ScalarType.String -> "VARCHAR"
    ScalarType.Boolean -> "BOOLEAN"
    ScalarType.Date -> "DATE"
    ScalarType.DateTime -> "TIMESTAMP"
}
```