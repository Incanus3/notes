=== Mon, 19.1. ===

==== EmailMachine ====
=== Import z XML ===
- after_create - import_file -> import_(local|remote)_file! -> import_xml
- import_xml
  - pomoci XmlFileSplitter rozseka na slicy (vysledne soubory v
    parser.file_paths)
  - na kazdy pak zavola RestApiResource::ContactList.import_xml_slice
  - nakonec zavola RestApiResource::ContactList.transfer_contacts
  - RestApiResource::ContactList.import_xml_slice vola Customer.import_xml_slice

== Customer ==
- radky 124-544
- 2 varianty - import_xml_data (nepouziva se) a import_xml_slice (350 radku)

== Product ==
- model ProductImport (AR) - -||-
  - asociovan s ProductImportBatch, ale zakomentovano
  - after_create -> import_file
  - #import_file - po splitu
    - pokud neni templateable_id, vola RAR::ProductImport#product_import_file
      (ktery vola Product.import_from_file)
    - jinak vola Product.import_from_file primo
- model Product (Neo4j) - v podstate cely
  - .import_from_file
    - volan z ProductImport#import_file, RAR::ProductImport.product_import_file,
      ProductImportsController#import_file

== SimpleEmailBatch ==
- metody generate_from_xml, get_addresses_from_xml



- RestApiResource.call(class, method, params)
  - makes request to embedded api
  - handles it in RestApi::BaseController by calling class.method(params) (using
    eval!)
  - this eval then calls some method on some class in RestApiResource module
  - is supposed to make requests to neo4j run in the main thread, since only one
    thread can have open connection to it
  - neo4j calls are somewhere deep in callstack - the wrapper calls could be
    much more closer to the actual calls
  - is quite confusing, since the methods implemented by 'model' classes under
    RestApiResource module MAINLY log the action, extract parameters from
    request and call methods on the real model, but part of the model logic is
    splilling over there
  - same methods may also be defined in both model and 'model' (under RAR),
    - model method wrapping RAR.call - ContactList#import_xml_slice
    - 'model' method calling the 'real' model one - ContactList#transfer_contacts
    ... making it even more confusing
  - should be replaced by some thread wrapper, which receives method call and
    execute it in one looping thread (using blocking queue either to store
    [class, method, args] structures or procs)

Neo4jThread.execute do
  # some neo4j calls
end

# OR

Neo4jThread.run(class, method, args)

- which is wery similar to the RestApiResource.call call, but when it's
  reimplemented using thread and queue, the name no longer makes sense
- since there's no request afterwards, we don't need to mind about serializing
  parameters (typically passing ids, then finding the records in request
  handler)

- the call chain often looks something like this
  ContactList#import_xml -> Import::XML::ContactList#api_transfer_contacts ->
  RestApiResource.call(:ContactList, :transfer_contacts, ...) -> request ->
  BaseController -> RestApiResource::ContactList.transfer_contacts ->
  ContactList#transfer_contacts - makes neo queries
- 1st step
  - since rest api should serve only to access neo in correct thread,
    it should never call back to AR model, only to neo model
  -> extract neo logic from models to neo models
  -> only call neo models from rest api
- 2nd step
  - normalize rest api method calls, extract all other logic and simplify it to
    dynamic dispatch
- 3rd step
  - replace it by a thread-connection wrapper
- 4nd step
  - neo models should themselve know, which blocks should be scheduled for neo
    thread - move either RestApiResource.call (before rewrite) or wrapper (after
    rewrite) calls there

[ ] zeptat se dominika, zda je v poradku, ze v import_xml se vubec nepouziva
    neo_id, vsude se RestApiResource.call predava db id
http://gitlab.it-logica.cz/mailing_parfums_crm/blob/6378c502f56129a90968a82256941a4ee603c5cf/app/models/contact_list.rb
[ ] zjistit, jak je to v import_xml s attributes - vypada to, ze zustane jako
    prazdna hash, co se s ni pak deje?
[ ] projit metody RestApi resourcu, ktere jsou volany z Import::XML::ContactList
- nektere jsou divne umisteny - treba
  ContactList.clear_neo_importing_contact_list vola vola tuto metodu na
  ::Customer
- zhodnotit, jaka cast prace by se dala zautomatizovat - resourcy porad pusobi
  jako redundantni prostrednik, ktery vytaha parametry a zavola metodu - neslo
  by nejak dynamic dispatchem (ktery uz se deje u call)
- pokud by VSECHNY metody odpovidaly metodam na modelech a pouze by relayovaly,
  melo by jit zautomatizovat - extrahovat ostatni logiku jinam a normalizovat
  nazvy
[ ] zjistit, jak je to se synchronicitou RestApiResource.call, potazmo
    RestClient::Resource#post

- jruby hlasi undefined pri volani private metody
