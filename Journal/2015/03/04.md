=== Wed, 4.3. ===

- prace - alto
  - 1-1.30 - studium SQLAlchemy ORM - Loading Objects
  - 3.30-4, 4.30-6, 6.30-10 - studium zbytku ORM
  - 12.45-1.30 - zvazovani kladu a zaporu pouziti ORM

- commit session in request.finish, rollback in error handler
- optionally establish new session in request.prepare and close it in request.finish
- another option is to use autocommit=True for the session, this highly simplifies the persistence
  concerns (committing, rolling back), but is of course much less effective. it could be used as a
  transient phase though, but this technique seems to be strongly discouraged
- scoped_session could also be used to achieve this and seems most appropriate
  - it solves the need to pass the session to all model calls
  - base model could provide session method, which will retrieve the session from registry (how
    efficient could this be? maybe some memoization could be used)
  - this can be easily achieved using the scoped_session().query_property()
  - handler would then create new session in prepare and remove it from registry in finish
  - this also makes the session thread-local

- AssociationProxy seems to be very useful to be used with many-to-many relationships

[ ] zvazit vyhody jednotlivych reseni ^
[ ] zjistit, jak je to s asynchronnosti tornada - co se dela v ruznych vlaknech a kde by mohlo dojit
    k problemum v pristupu

[ ] zvazit vyhody a nevyhody pouziti ORM vrstvy - proletet tutorialy jeste jednou
+ vysokourovnejsi rozhrani - metody mohou vracet query objekt, jehoz metody lze volat primo z
  handleru, nebot neleakuji abstrakci -> chainovani volani nad query
  - pri pouziti Core je treba chainovat volani na statement (select, insert, ...), ktery je ale pak
    treba vyhodnotit v ramci spojeni - nelze s nim pracovat vne modelu (abstraction leak)
  - ORM Query objekt jednou vytvoreny ze session lze snadno vyhodnotit terminalem (all, one,
    scalar), coz je rozumna uroven abstrakce pro volani z vnejsku
+ snazsi prace s asociacemi, joiny, moznosti eager loadu, atd.
+ session funguje castecne jako cache (identity map), takze recordy se v ramci jedne session
  (nejspis bude otevirana pro request) neloaduji opakovane
+ lze pridavat metody primo instancim - netreba definovat vsechno jako class metody berouci jako
  prvni parametr id a pokazdy znova vyhledavaji record
+ umoznuje definici listeneru -> napr. validace hodnot, automaticka koerce/serializace a dalsi
  pre/post-processing + reakce na dalsi eventy jako pridani/odebrani has many asociace, ...
+ umoznuje dosahnout na aplikacni urovni vsemozneho kaskadovani (on delete, on update)
+ vsechny zapisy se provedou az pri commitu - cely request probiha v ramci transakce

- podstatne sirsi rozhranni - delsi uceni, ze zacatku vetsi chybovost
- treba spravovat session - inicializovat na zacatku requestu, commitnout/rollbacknout a zavrit na
  konci
  - lze velmi zjednodusit pouzitim scoped_session (registry pattern)
- treba premyslet nad stavem persistence objektu, muze byt problem s vlakny (zjistit, jak je to s
  vlakny v tornadu)
  - scoped_session http://docs.sqlalchemy.org/en/rel_0_9/orm/contextual.html snadno umoznuje udelat
    session thread-local, stale ale hrozi, ze bude tentyz objekt pristupovan ze dvou session zaroven
- vsechny zapisy se provedou az pri commitu - treba osetrit vsechny chyby, ktere mohly vzniknout
  + centralizace handlingu
  - v nekterych pripadech muze ztizit situaci, napr. ve chvili, kdy je potreba po chybe pokracovat
    dal
    - treba pridat subtransakci a osetrit jeji commit
    - nebo lze resit pouzitim Core v techto pripadech (Core lze krasne kombinovat s atributy a
      nejspis i asociacemi definovanymi na urovni ORM)

* pro jednoduche api, jakym je datastore, je uzitecnost pouziti ORM hranicni, pokud by se ale nad
  daty delaly postupne slozitejsi aplikace, zacne se nejspis vyplacet a bylo by sikovne mit modely
  jenom jedny a znovupouzit je
* vzhledem k slozitosti ORM bude navic sikovne zacit se s nim szivat co nejdrive
* vyhodou take je, ze ORM lze snadno zarazovat inkrementalne - bud implementovat v nove ModelBase
  stejne API, nebo upravit jen nektere modely a jejich volani
[ ] zvazit, co vsechno by prechod obnasel
[ ] podat report k issue
[ ] rozebrat s evzou
