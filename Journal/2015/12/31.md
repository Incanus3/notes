=== Thu, 31.12. ===

- 18.30-22.30 - studium ads

==== Celkove ====
- nulova dokumentace kodu - obcas by clovek ocenil nejake komentare - k cemu trida slouzi apod.,
  nebo aspon readme ohledne struktury kodu, vstupnich bodech
- nikde nerozlisuje verejne rozhrani trid - priklady a motivace dale
- tuna mrtveho kodu

=== das ===
- nedela nic jineho, nez ze zabali parametry a telo requestu do dictu a preda druhemu API, navic GET
  i POST preklada na GET
- main_das definuje a pouziva MainHandler, handler/base definuje BaseHandler, ale ten se nikde
  nepouziva - melo by byt aspon popsano

=== dc ===
+ rozumne strukturovany kod - tridy a metody jsou koherentni
  https://en.wikipedia.org/wiki/Cohesion_(computer_science)
+ pekne pouzita dedicnost - model -> Tab -> Dat
+ vetsinou rozumne vyuziva moznosti jazyka a standardni knihovny
  - nektere veci by sly napsat jednoduseji napr. pomoci list comprehentions, map
- spousta mrtveho kodu
- zbytecny vedlejsi efekt - priklady dale
  - tok dat mezi metodami je mnohem hure pochopitelny, pokud metoda ulozi vysledek do nejakeho
    atributu, kde ho posleze nekdo precte, misto aby ho vratila
  - pokud nekolik metod nastavuje stejny atribut (coz se v kodu deje), clovek musi vedet, ktera z
    metod byla zavolana naposled, aby vedel, odkud data vlastne pochazi
  - treba davat pozor, aby se atribut necetl pred prvnim volanim metody a aby mi ho pred ctenim
    neprepsalo volani metody z jine casti kodu
  - hrozi chyby soubehu
  - ...
- chybi error handling - volajici musi resit vsechny mozne chyby sam
- krypticke nazvy promennych
  - pouziva prefixy, ktere maji evidentne nejakou logiku (nejspis oznacuji datovy typ promenne a
    jeji lexikalni rozsah - vstupni hodnota, parametr, lokalni promenna)
  - prefixy ale nejsou nijak oficialne ustalene, mely by tedy byt aspon zdokumentovany
  - v rozumne strukturovanem kodu jsou navic celkem zbytecne - u metody na 10 radku snad vidim,
    jestli jde o parametr, lokalni promennou, nebo atribut instance (self)

- shrnuti - celkove pusobi rozumne, vetsinu uvedenych problemu lze velmi snadno odstranit
  - trochu vic prace bude pridat error handling, ale nic hroznyho

== Dat ==
- spousta mrtveho kodu (metody, ktere se nikde nevolaji) a nepouzitych promennych
  - jestli si autor mysli, ze se kod jeste pouzije, mel by byt aspon okomentovan, jako aktualne
    nepouzivany, jinak hrozi, ze pri zmene nejake metody, kterou vola, se ho bude nekdo snazit
    zbytecne opravovat
  - nektere metody vypadaji, ze se sem dostaly omylem z nejakeho RequestHandleru (serverova cast)

- nerozdeluje public a private metody (check_input_data, prepare_filter, export_data a nejspis
  create_row by mely byt private)
  - pokud chci zmenit chovani nejake metody, musim krome opravy jejich volani v ramci tridy hledat,
    zda se nevola zvenci, protoze to neni jak poznat

- imperativni rozhrani metod - spoleha na vedlejsi efekt
  - kdyz chci volat dat_get, musim
    - nastavit ivs_filter atribut - cte Tab.prepare_filter
    - zavolat dat_get             - vyheda zaznamy, ulozi v ivl_data atributu
      - ulozeni provede metoda check_input_data (skrze create_row), coz moc nedava smysl a clovek to
        neceka, kdyz kouka na kod, ktery metodu vola
    - precist data z ivl_data attributu

    - filter by mel byt vstupnim parametrem dat_get, vysledek by mel byt vracen, nikoli ulozen do
      ivl_data
    - krome neprehlednosti kodu hrozi race conditions, pokud by se paralelizovalo (coz neni u http
      api klienta nic vyjimecneho - cekani na response trva, tak proc bych necekal na 5 zaroven)
      - pokud bych pouzil jeden objekt Tab (a proc ne, kdyz reprezentuje pristup k jedne tabulce),
        budou se mi pri volani dat_get hadat o ivl_data a ukladat do nich vysledky ze vsech bezicich
        dotazu

  - kdyz chci volat dat_post, musim
    - nastavit ivl_data atribut - cte metoda export_data, mel by byt vstupni parametr
    - zavolat dat_post
    - sam vyhodnotit vyslednou odpoved - kod nekotroje ani status code
      - chybi error handling - pokud se napr. prerusi spojeni, metoda proste vyhodi nizkourovnovou
        chybu

- podivne chovani
  - Dat.__init__ vola create_row, ktery sice v Dat nic nedela, ale v Tab prida do ivl_data (vystupni
    atribut po dat_get) defaultni radek (definovany potomkem Tab)
    - ten se sice nastesti pri zavolani check_input_data nejdriv vyprazdni, pokud bych ale cetl
      ivl_data pred prvnim volanim, tak ho zde najdu

== Doc ==
- check_input_data
  - ma neocekavany vedlejsi efekt

== Tab ==
- check_input_data
  - ma neocekavany vedlejsi efekt
  - domnivam se, ze obsahuje celkem kritickou chybu - viz okomentovany kod
- get_rows_json
  - matouci nazev - nevraci json, nybrz normalni dict
  - primo pristupuje k Row.__dict__

== Row ==
- matouci pouziti __dict__ - viz komentare v kodu


=== ads ===
- spousta mrtveho kodu, zadne komenty (ani o tom, ze jde o mrtvy kod)
- enormne neprehledne, malo strukturovane (hlavne 2 metody DbSql)
- spousta veci jde napsat na 1/6 radku a podstatne prehledneji
  - nevyuziva moznosti jazyka a standardni knihovny
  - rucne lepi SQL dotazy - pracne a nebezpecne - misto aby pouzil vysokourovnovejsi knihovnu
    - navic zbytecne slozity postprocessing sql vysledku - nebylo by vubec potreba
- nulovy error handling
- tuna duplikace - musim cist 5x totez, pokud chci zmenit, musim na 5 mistech (a na zadne
  nezapomenout)
- kdyz mluvim o setreni readku, nejde o mi samotny fakt, ze kod je kratsi, ale o to, ze pokazde,
  kdyz k nemu znova prijdu, musim cist 20 radku misto 3 (a 5x tutez sekvenci instrukci misto jedne
  pomocne metody)
- krypticke nazvy promennych a metod (narozdil od dc ale casto bez zjevne logiky - viz metody DbSql)

- shrnuti - dost hrozne, jak po programatorske strance, tak co do pohodlnosti prace s API z
  klientske strany

== ads.py ==
- main - instanciuje DbSql, ulozi do globalni promenne Db, ke ktere pak metody MainHandleru
  pristupuji - hnus - mel by byt class atribut MainHandleru - main instanci nepotrebuje a hlavne je
  v MainHandleru matouci, odkud Db pochazi - zvlast kdyz je definovana az po definici MainHandleru

- MainHandler
  - get - nedela nic, jen vrati prazdne telo
  - post - podle parametru v tele deleguje metodam Db:
    - cursor_adapter -> mel_ca_get_rows
    - tu             -> ca_tu
    - select         -> mel_select00
      - vyhodnoti select tak, jak ho dostane - velmi nebezpecne - klidne muzu jednim http dotazem
        promazat celou db
      - jestli je fakt potreba (jako ze si nemyslim, ze by melo), tak pouzit rozumne zabezpeceni -
        digest auth nebo https + basic auth

== ClassSql.py ==
- obecne
  - tuna mrtveho kodu - mel_select_par, med_zoznam, med_pohlad
  - krypticke nazvy metod a promennych - viz vyse
  - velmi malo strukturovane - obrovske metody mel_ca_get_rows a ca_tu
  - zvenci se volaji 3 metody, ale public jsou vsechny (nikde prefix _)
  - dvoji definice funkce U - prevadi na unicode, nejspis puvodne pro kompatibilitu s pythonem 2
    - jednou jako globalni funkce, jednou jako metoda DbSql
  - tuna duplikace
    - 4 temer identicke metody - mel_select00, mel_sql_update, mel_select_par, mel_sql_update_par
      - lze napsat jako jednu s volitelnymi parametry pro execute a priznakem, zda volat commit
        (nebo ho klidne volat pokazde)
    - nacitani json definic ze souboru
  - zbytecna prace s SQL - viz vyse a v komentarich v kodu
  - nulovy error handling

- metody
  - init - nastavuje jediny atribut ivo_coding, ktery se nikde nepouziva
  - men_get_connection - slo by napsat na 2 radky (viz commenty v kodu)
  - fud_select_format - prevadi sql vysledky na seznam dictu, ktery se pak posle klientu
    - mela by byt private
    - ma 20 radku, ktere je potreba studovat 15 min
    - da se napsat na 3 radky, jejichz funkce je od pohledu zrejma - viz alternativni verze v kodu
    - kombinuje transformaci vystupu (mohla by byt pure function) s vedlejsim efektem volani dotazu
      nad db - podstatne hure testovatelne
    - nemluve o tom, ze
      1) o funkci by mel vypovidat uz nazev
      2) pri pouziti vysokourovnovejsi knihovny (napr. SQLAlchemy Core) by nebylo vubec potreba
    - ztrati se typ hodnot - vsechno prevadi na string!
  - mel_ca_get_rows - taha data z db
    - extremne dlouha, sestava z logickych kroku, ktere lze extrahovat do pomocnych metod
    - duplikace nacitani definice tabulky z json souboru - stejne v ca_tu
    - navic se naprosto zbytecne provadi pri kazdem volani, coz je extremne neefektivni (nejspis
      podstatne pomalejsi, nez vetsina db dotazu)
    - nulovy error handling
  - ca_tu - zapisuje data do db
    - extremne dlouha, sestava z logickych kroku, ktere lze extrahovat do pomocnych metod
    - duplikace nacitani definice tabulky z json souboru - stejne v ca_tu
    - navic se naprosto zbytecne provadi pri kazdem volani, coz je extremne neefektivni (nejspis
      podstatne pomalejsi, nez vetsina db dotazu)
    - nulovy error handling
    - velmi nebezpecne - nachylne k SQL injection
    - 2 ruzne typy zapisu volani SQL dotazu - parametricky a primy, pricemz
      - parametricky je jednodussi a bezpecnejsi - lez se vyhnout SQL injection
      - proc ho tedy nepouzit vsude
      - nemluve o tom, ze by se 20x zjednodusilo pouzitim vysokourovnovejsi sql knihovny

== ClassCoding.py ==
- mrtvy kod
  - definuje jednu prazdnou tridu a dve funkce, ktere pouze vraci vstupni parametr
  - puvodne evidentne slouzilo pro prevody unicode a base64
  - funkce se opakovane volaji z ClassSql.py

== ClassAasMetody.py ==
- mrtvy kod - nikde se nevola, puvodne se volalo z ads.py main
