=== Tue, 26.4. ===

- 11-12 - pokracovani v rozmysleni modelove vrstvy - nastaveni related objektu
- 15-18 - pocatek programovani repository

https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty
https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/get
https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/set
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters
https://bl.ocks.org/joyrexus/65cb3780a24ecd50f6df - properties in coffeescript
http://stackoverflow.com/questions/11587231/coffeescript-getter-setter-in-object-initializers
- properties in coffeescript - see 2nd answer for a way w/o poluting Function prototype

http://coffeescript-cookbook.github.io/

== external repository interface ==

repository.articles.find(id)
repository.articles.all()
repository.articles.where(name: 'asdf')

# these should return objects/collection of objects, which can lazyly load their association using
# the repository they were acquired through
# -> for each foreign key, e.g. action.conditionTypeID (this will be a bit harder for *-to-many side
#    of the relationship), there should be a property, e.g. action.conditionType, which finds the
#    associated object by that key

# ideally we'd like to preload all objects in the relation and then work with them client-side only
# but that may not be possible for relations with many objects
# how should this work then?

# for create to work as expected (populating relations from repo) we'd need to save it's return
# value (which the caller may easily forget), to force it, create could take the attributes instead
# of an unbound instance
# we could also modify the passed in instance, but that doesn't seem very clean
# - let's do that for now and clean it up later

repository.articles.create(article)
repository.articles.update(article)
repository.articles.delete(id)

# there could also be some unit-of-work kind of mechanism - the creates and updates would only take
# effect (on the server side) after issuing some repository.commit() call
# there are two reasons for this
# - ability to rollback the unit of work
# - effectivity - but this only makes sense, when the API supports some batch create/update/delete
#   actions

== model interface and registration ==

class Action extends Model
  constructor (@name, @conditionTypeID) ->

  @relations:
    conditionType: @hasOne(ConditionType, 'conditionTypeID')

  # this relation must return object(s) bound to Action's repository -> it cannot call methods
  # directly on ConditionType class, but instead of repository.conditionTypes, how can this property
  # name be inferred? the model class shouldn't store reference to the repository, since it may be
  # registered in several repositories, but the model instance has a link to the repository it
  # belongs to and the repository knows, which of its properties belongs to which model class

class Repository:
  @register (cls) -> ...

class ActionRepository extends Repository

ActionRepository.register(Action, 'actions')
ActionRepository.register(ConditionType, 'conditionTypes')

now every instance of ActionRepository has two properties - repository.actions and
repository.conditionTypes, whose methods return models bound to that repository instance
