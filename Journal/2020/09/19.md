=== django + DRF authentication ===

- django:
  - django.contrib.auth.middleware.AuthenticationMiddle injectuje users do requestu:
    `request.user = SimpleLazyObject(lambda: get_user(request))`
  - request.user je tedy lazy atribut, ktery pri prvnim accessu zavola `get_user(request)` a pote cachuje
  - django.contrib.auth.middleware.get_user(request) vola django.contrib.auth.get_user(request) a pak
    jeste cachuje v request._cached_user
  - django.contrib.auth.get_user vytahne user_id a backend_path z request.session, loadne backend a
    zavola backend.get_user(user_id)
    - nevola tedy authenticate, hodnoty v request.session uz musel nastavit nekdo predtim

- DRF:
  - view:
    - u APIView se nastavuji class attry `authentication_classes` a `parser_classes`,
      prip. fallbackuji na `settings.REST_FRAMEWORK.DEFAULT_AUTHENTICATION_CLASSES` a `DEFAULT_PARSER_CLASSES`
    - pri zavolani view se vola metoda `dispatch`, ta vola `self.initialize_request` (nejspis) s
      django requestem
    - APIView.initialize_request vytvori a vrati instanci rest_framework.request.Request,
      jako authenticators ji preda seznam instanciovanych authentication_classes a jako parsers
      seznam instanciovanych parser_classes
  - request:
    - rf.Request ma properties (gettery i settery) user a auth
      - ty bud vraci `self._user`, resp. `self._auth`, pokud uz je nastaveno, nebo volaji
        `self._authenticate`
      - _authenticate prochazi self.authenticators a vola na ne
        `authenticator.authenticate(self)`, pokud uspeje, nastavi self.user, self.auth a
        `self._authenticator` (ktery lze ziskat volanim property `successful_authenticator`
    - rf.Request ma properties (jen gettery) `POST`, `FILES` a `data`, ty vraci `self._data`,
      `self._files` a `self._full_data`, pokud jsou nastavene, nebo volaji metodu `_load_data_and_files`
      - ta vola metodu `_parse` a nastavi atributy
      - ta pomoci negotiatora vybere parser a zavola na nej `parser.parse(stream, media_type, context)`
      - `rest_framework.parsers.JSONParser.parse` proste dekoduje stream a posle na nej `json.load`
  - authenticator:
    - rest_framework.authentication.TokenAuthentication.authenticate
      - vytahne header z requestu, rozseka na slova
      - zkontroluje, ze obsahuje prave dve slova
      - zkontroluje, ze prvni slovo odpovida keyword, tedy "token"
      - dekoduje druhe slovo a preda metode `authenticate_credentials`
      - ta se chova podobne, jako override v danube.auth.TokenAuthentication (dale), akorat neresi
        expiraci a jako model pouziva rest_framework.authentication.models.Token

- foodie pouziva jako DEFAULT_AUTHENTICATION_CLASSES `danube.auth.TokenAuthentication`, ktera
  - dedi z rest_framework.authentication.TokenAuthentication
  - nastavuje class attr model na `security.models.Token`
    - custom class, ktera generuje token pomoci os.urandom :)
  - overriduje metodu `authenticate_credentials(key)` tak, ze vola `self.get_model().objects.get(key = key)`
  - pokud najde, token neni expirovany a user je aktivni, updatuje token.last_used_at a vrati
    (token.user, token)
  - jinak hazi rest_framework.exceptions.AuthenticationFailed s odpovidajicimi messages
  - rf.Request._authenticate tedy nastavi vraceneho usera jako `request.user`
    a token jako `request.auth`

- parser nema vubec pristup k requestu
- authenticator ma pristup k requestu, ale nikdy ho nemodifikuje
