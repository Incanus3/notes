==== foodie MR 24 - print czech bills ====

=== danube.services.printer_markup.builder ===

- TableDisplay
  - prejmenoval bych na TableStyle (display jako podstatne jmeno je podle me neco trochu jineho)
    a vnoril do Table (pak nepotrebuje prefix)

- Formatter
  - aby bylo `is_set` false, musi byt podle me value explicitne nastavena na NOT_PROVIDED,
    protoze default v konstruktoruje `False`
  - definuje `__bool__`, ktere vraci `self.value`, nikoli `bool(self.value)`
    - vysledkem tedy nemusi byt nutne booleovska hodnota
  - definuje `__call__`, ktera bere string a vraci ho obaleny `start_seq` a `end_seq`
    bez ohledu na `value`
  - uklada `value` a par accessoru nad ni, ale sam ji vlastne vubec nezohlednuje - feature envy
    - vic reseno nize u BoldTokenMixin
  - celkove moc nezapada do zbytku
    - udelal bych jako nejaky `WrappedToken`, ktery bude misto `__call__` definovat klasicky `render`

- TemplateToken
  - `root_token` - pridal bych prefix `is_`

- TokenContainerMixin
  - definuje class atribut `valid_items` (inicializovan na None, ale vola se na nej in, takze by melo
    implementovat `__contains__`)
  - ma dost nekonzistentni terminologii, jak uz je psano v diskusi
    - data vs items vs contents (jinde)
    - ja bych prejmenoval:
      - vsechny `data` (atribut, nazvy metod) -> `contents`
        - parametry bych klidne nechal jako `token` - obsahem (contentem) "token containeru" jsou tokeny
        - kdyz se prejmenuje i SingleContentToken._data na _content, bude konzistentni, akorat
          SingleContentToken ma jeden content, zatimco TokenContainerMixin ma vic, tedy contents
      - valid_items -> valid_token_classes

- BoldTokenMixin
  - definuje cached_property `bold`, ktera vraci `Formatter` se `start_seq` a `end_seq` nastavenymi
    na `bold_on` a `bold_off`
    - cached_property dela to, ze pri prvnim volani zavola dekorovanou funkci a jeji vysledek ulozi
      do atributu, ve kterem puvodne byla property - pri pristim accessu uz se tedy vraci ulozena hodnota
    - `BoldTokenMixin` ale vola `self.bold` rovnou v konstruktoru, takze pouziti cached_property
      dost pozbyva smyslu - konstruktor mohl normalne nastavit self.bold na instanci `Formatter`u
    - pokud by Formatter delal pouze formatovani (obklopeni stringu pocatecni a koncovou seq), mohla
      by instance, kde start_seq = bold_on a end_seq = bold_off byt singleton a nemusel by se znova
      instanciovat v kazde instanci `BoldTokenMixin`
    - kdyz uz uklada hodnotu, podle ktere se pak kod, ktery ho pouziva, rozhoduje, prislo by mi
      logicke, aby se podle nej rozhodovalo ve volani `__call__`, tak jak je se
      1) porusuje zapouzdreni - instance `Formatteru` hodnotu uklada, ale vzdycky k ni pristupuje
      caller a to jeste neprimo skrze implicitni `__bool__` - feature envy
      2) porusuje "tell, don't ask" - zeptam se `Formatteru`, jaka je ulozena hodnota (kterou jsem
      mu sam nastavil), abych ho na zaklade ni volal tak, nebo tak (prip. nevolal vubec)
      3) nazev `Formatter` neni plnohodnotny, protoze jde soucasne o jakysi "value carrier"
    - idealne by tedy
      - bud mel formatter ukladat priznak, ale pak se podle nej rozhodovat v tele `__call__` a podle
        jeho hodnoty bud obklopovat, nebo neobklopovat string pocatecni a koncovou sekvenci, caller
        by pak volal bezpodminecne a na hodnotu uz by se nikdy neptal
      - nebo by mel delat pouze formatovani a hodnota by se mela ukladat v calleru, tedy napr.
        `BoldTokenMixin` by mel ukladat priznak, zda-li je ci neni bold, primo a `Formatter` pak
        volat jenom kdyz ano
        - pak je ale `Formatter` celkem zbytecny, kdyz jedine, co dela, je, ze obaluje format string
          do metody `__call__`, zvlast kdyz `start_seq` a `end_seq` stejne poskytl caller
  - definuje `render`, ktery vola `super` se `string = self.bold(string) if self.bold else string`,
    coz je zvlastni ve dvou vecech
    - `string` nemusi byt string, ale muze byt instance `Formatteru`
      - `Formatter` dokonce neimplementuje `__str__`, pouze `__call__`
    - `self.bold` je podle me vzdycky true - vraci (cachovanou) instanci `Formatteru`
      - mozna to tak neni - `Formatter` totiz implementuje `__bool__`
      - vola se ale `__bool__` na podminku `if`u implicitne?
      - i kdyby ano, prijde mi dost matouci pouzivat tutez property pro dva ruzne ucely - jednak
        uklada (bezpodminecne) instanci Formatteru, jehoz `__call__` bude vzdycky zahrnovat
        `bold_on` a `bold_off`, jednak se pouziva v podminkach jako priznak, zda je dany token
        tucny, nebo ne

- SingleContentToken
  - dedi z `TemplateToken` a `BoldTokenMixin` (to mi prijde trochu zvlastni - proc by kazdy `SCT` mel
    byt potencialne tucny? spis by mi davalo smysl, kdyby byl `TextToken`, ktery by dedil z
    `SingleContentToken` a soucasne includoval `BoldTokenMixin`. dalsi potencialne tucne tokeny by mely
    includovat `BoldTokenMixin` samy)
  - konstruktor bere `content`, ktery ulozi do `self._data` a kwargy, ktere posle vys
    (nekonzistentni terminologie, navic pouziva stejny nazev jako `TokenContainerMixin`, prestoze z
    nej nededi; to sice samo o sobe nevadi, ale vzhledem k tomu, ze se trida vyskytuje mezi spoustou
    trid, ktere z `TokenContainerMixin` dedi, musi se clovek zamyslet, co se vlastne s `_daty` bude
    dit dal a jestli to nejak souvisi s tim, jak s nimi pracuje `TokenContainerMixin`)
    - prejmenoval bych na `_content`

- SingleContentToken a TokenContainerMixin
  - vypadaji jako podobne koncepty, ale
    - jeden ma jeden content, druhy mnoho, to je logicky
    - nemaji konzistentni nazvy - ja bych volil proste SingleContentToken a MultiContentToken
    - jedno je class a jedno mixin
      - udelal bych oboji jako tridu, nebot se da rict, ze napr.
        TableRowContent je MultiContentToken, tedy pomer "is a"
      - TokenContainerMixin by proste dedil z TemplateToken a jeho potomci uz by nemuseli
        - AlignTokenContainer by se tim taky stal Token classou, coz by podle me nevadilo,
          stejne implementuje render
        - tu bych ale stejne nejspis zrusil viz nize

- LeftAlignToken, CenterAlignToken, RightAlignToken
  - dedi z `SingleContentToken`
  - pokud by reprezentovaly pouze znacku pro alignment, bylo by v poradku
  - pokud reprezentuji cely xxx-aligned content, dal bych do nazvu Aligned

- AlignTokenContainer
  - `render` predpoklada, ze prvky `self._data` jsou renderable, coz zde ale neni nijak zajisteno
    (napr. pomoci `_validate_data`)
  - `__len__` opet predpoklada, ze prvky maji `__len__`, coz neni zajisteno
  - zadna z metod navic nijak nesouvisi s alignmentem a mohly by klidne byt primo
    v `TokenContainerMixin`
  - jediny duvod, ktery bych pro tuto tridu videl, je, ze muze obsahovat jen konkretni typy tokenu
    (napr. SingleContentToken a jeho potomky, protoze ten definuje `__len__`, se kterou
    AlignTokenContainer u svych contentu pocita), pak by ale mela definovat `_validate_data`

- LineToken
  - `render` - vola super s tim, ze preskoci implementaci `BoldTokenMixin` (pokud chapu spravne),
    jedine, co se tedy z `BoldTokenMixin` pouzije je atribut `self.bold` (tedy instance
    `Formatteru`, viz vyse)
  - `_calculate_center_align` a `_calculate_right_align`
    - nazval bych jinak, asi padding - align se celou dobu pouziva pro oznaceni typu zarovnani (tedy
      vlevo, vpravo, na stred), tady se ale najednou pouziva pro ciselne hodnoty, ktere se pouziji
      jako padding/separator ruzne zarovnanych casti radku

- FilledLineToken
  - `add_data` haze TypeError
    - nejsem si jist, zda TypeError je vystihujici, udelal bych custom exception class
  - `render`
    - dalo by se udelat jednoduseji - vydelit sirku papiru delkou `filled_with`, zaokrouhlit nahoru,
      tolikrat repeatovat `filled_with` a nakonec cely string zkrouhnout na sirku papiru

- EmptyLineToken
  - `add_data` haze TypeError - ditto

- TableCellToken
  - definuje reader i writer `column`, ani jeden nedela nic dalsiho, proc teda neni rovnou public
    atribut? na property se da predelat vzdycky, kdyby bylo potreba pridat logiku pri cteni/zapisu
  - `is_empty` - neni specificke pro table cell, muze byt klidne rovnou v `SingleContentToken`
  - `render` - zde se padding korektne nazyva padding, nikoli align, jako je to u `LineToken`

- TableHeaderCellToken
  - `text_align` nefallbackuje na `self.column.text_align` jako TableCellToken. proc?

- TableRowToken
  - volitelne renderuje `separator` - nevim, jestli bych spis neudelal spesl `SeparatorRowToken`
    (dedit z `FilledLineToken`, nejspis nebude delat nic navic, jen pro prehlednost), nez ho
    renderovat v ramci predchoziho radku
  - `table` reader a writer (ktere nic dalsiho nedelaji - proc neni public attr?)

- TableHeaderToken
  - `render` vrati prazdny string, pokud jsou vsechny bunky prazdne, jinak deleguje na `super`
    - proc je treba takto rozlisovat? jestli chapu spravne, jedinym viditelnym rozdilem bude, ze se
      nevyrenderuji bordery mezi sloupci (ty jsou ale stejne tvoreny mezerami). je to tak spravne?
      a kdy to nastava?

- TableToken
  - nested class `Column`
    - nested class `Border`
      - konstruktor bere `width`
        - defaultuje na module-level const `DEFAULT_TABLE_COLUMN_BORDER_WIDTH`
          - presunul bych do `TableToken.Column.Border.DEFAULT_WIDTH`
        - ulozi do `self.width`, nikoli `self._width`, cimz prepise property `width`
          jaky ma smysl definovat attr na tride, kdyz se tak ci tak prepise?
      - definuje i zapisovou metodu width, ktera kontroluje, ze hodnota neni < 0
        - mozna bylo zamysleno jako writer, pak by davalo smysl, ze konstruktor prirazuje do
          `self.width`, nikoli `self._width`
      - `__len__` vraci `self.width`
        - to mi prijde zbytecne - pouzival bych explictne `border.width` a ne `len(border)`

    - ma `pull` - prevede na instanci `Pull`
    - ma `text_align` - je v poradku, ze pull se coercuje, ale text_align ne?
    - metoda `add_cell` - bere `cell` (jakeho je typu? pridal bych anotaci) appenduje do
      `self._cells`, pokud je len(cell) > `self.width`, nastavi `self._width` na `len(cell)`
      - pokud neni `cell` raw string, pouzil bych explicitne `cell.width`, predpokladam, ze `cell`
        je instance `TableCellToken`, pak bych pridal `width` property, ktera vraci `__len__`
    - custom constructor `from_cell` bere `table` a `cell` (soudim, ze `TableCellToken`,
      typoval bych), `cell` ignoruje, vraci novou instanci s pull = `table.default_pull`
    - custom constructor `from_header_cell` bere `table` a `cell` (soudim, ze `TableHeaderCellToken`,
      typoval bych), `cell` ignoruje, vraci novou instanci s pull = cell.pull or table.default_pull,
      text_align = cell.text_align
      - proc `from_header_cell` zohlednuje `cell.text_align`, ale `from_cell` ne? chapu, ze pull
        musi mit cely sloupec stejny, takze se bere podle headeru, ale text align bych si myslel, ze
        muze byt ruzny u hlavicky a bunek - pak bych bud cekal, ze se bude nastavovat na vsech
        bunkach (nepohodlne), nebo ze bude mit `TableHeaderCellToken` extra atributy
        `header_text_align` a `body_text_align`. mozna se s tim ale zatim proste nepocita, coz neva

  - metoda `_recalcutlate_borders`
    - spocte sirku obsahu, zbyvajici misto, rozdeli mezi sloupce (nemelo by se delit na
      `columns_count - 1` casti?)
  - metoda `_recalcutlate_borders_for_center`
    - `first_column` a `last_column` by mely jit ziskat deterministicky indexaci, netreba
      inicializovat na None a pak v kazdem kroku reassignovat
    - outer_boarders_total_width by slo ziskat snadno sumem nad comprehension
    - kdyby se tak udelalo, muze se left_border a right_border ruznym sloupcum nastavovat
      unifikovane, zatimco takhle se neco nastavuje v ramci cyklu a neco az za nim
    - vsechny 3 body jsou ale otazkou stylu
  - metoda `_recalcutlate_borders_for_pull`
    - plati, ze kazdy `column` ma `pull` bud `LEFT`, nebo `RIGHT`?
      - pokud ano, da se navyseni `side_boarder_width` hodit mimo podminku, nebo dokonce spocitat
        uplne pred cyklem
    - `first_pulled_right_column` se nastavuje v ifu, zatimco `first_column` v
      `_recalcutlate_borders_for_center` se nastavoval `or`em (coz bych preferoval),
      prestoze jde o stejne konstrukty
    - pokud existuje i `last_pulled_left_column` i `first_pulled_right_column`, rozdeli se
      `side_boarder_width` mezi jejich prilehajici bordery
      - nestacilo by pokryt jednim z nasledujicich pripadu a proste pricist `side_boarder_width` k
        jedne nebo druhe strane?
  - `_validate_pull_column_ordering`
    - u prvniho ifu je zbytecna prvni pulka podminky - prinejhorsim se nastavi na True nekolikrat
  - `_initialize_columns_by`
    - pokud je `row_or_header` headerem, nastavi `self._has_header` na true
      - prvni pulka podminky je zbytecna
    - nastavi promennou `column_factory` bud na `Column.from_header_cell`, nebo `Column.from_cell`
      podle toho, zda je `row_or_header` header a tu pak vola na jednotlive bunky z
      `row_or_header.cells`, pricemz vysledky appenduje do `self._columns`
      - kdyby `is_header` byl atribut `TableHeaderToken` a `TableRowToken`
        (podobne jako `root_token`), mohl by mit `Column` pouze metodu `from_cell` a rozhodoval by
        se sam, podle typu tokenu, takhle opet porusuje "tell, don't ask"
  - `_assign_cells_to_columns`
    - operuje nad odpovidajicimi dvojicemi sloupec+bunka z `zip(self.columns, row.cells)`,
      pricemz row dostane parametrem, ale `columns` bere ze `self`
      - bylo by lepsi, kdyby se k obema chovala stejne, tedy brala obe parametrem
        - jednak bude chovani k nim jednotnejsi
        - jednak bude mensi coupling s metodou `_initialize_columns_by`
          - takhle je totiz implicitne zavisla na tom, ze `_initialize_columns_by` uz se zavolala,
            jinak by `self._columns` nebylo nastaveno, kdyz bude brat parametrem, je zavislost
            naprosto explicitni, telo metody vubec nebude zajimat, odkud se `columns` vzaly a caller
            bude muset predat, tudiz je nejdriv musi nekde ziskat
  - metoda `_is_table_header`
    - testuje, ze row je instanci `TableHeaderToken`
    - tohle by mel byt atribut `TableHeaderToken` a `TableRowToken`


- PrinterTemplateBuilder
  - nenazyval bych builderem - pod builderem si predstavim, ze vraci nejakou strukturu objektu,
    ucelem tohohle je vyrenderovat templatu do finalni textove podoby, takze jde podle me o
    template renderer
  - metoda `build_from_string`
    - bere `template`
    - zavola `self.build()`
      - vysledek ulozi do promenne `template`, tedy prepise tu z parametru
      - vysledkem uz ale neni template, nybrz finalni text, ktery se posle na tiskarnu, (coz je
        mimochodem videt i v `Printer(Service).print_bill`, ktera vysledek uklada do promenne
        `bill_text`), tak bych to podle toho nazval (jak v `build`, tak v `build_from_string`)
    - zavola `parser.close()` - proc se nemuze volat pred volanim `self.build()`?
      - s parserem uz by behem buildu zadna interakce byt nemela
  - metoda `build`
    - pocita s tim, ze uz se zavolalo `parser.feed` (resp. ze se `build` vola z `build_from_string`),
      tedy ze pole `self._template_tokens` je naplneno
      - opet implicitni coupling, podobne jako u `TableToken._initialize_columns_by`
        a `._as_assign_cells_to_columns`
      - metoda by mela byt privatni, nebot nedava smysl volat ji jinak, nez skrze
        `build_from_string`
  - trida ma tri velmi odlisne zodpovednosti (coz uz samo o sobe porusuje SRP)
    - orchestrace celeho sestaveni - import a instanciace parseru, feednuti vstupni templaty, build
      vystupniho textu z tokenu, ktere jsou vysledkem parsingu
    - poskytnuti factory metod, ktere instanciuji `...Token`y
      - tohle je sice celkem neskodny, ale nevidim duvod to v ramci SRP neoddelit
    - uchovavani seznamu jiz zparsovanych tokenu v prubehu probihajiciho parsu
      - hlavne tato zodpovednost je problematicka, protoze
        - jde o vedlejsi efekt, ktery neni na prvni pohled primo videt - metoda `add_token` se z
          PrinterTemplateBuilder primo nikde nevola
        - cini celou instanci PrinterTemplateBuilder mutable (a volatile), byt by sama o sobe byt
          nemusela, nebyt teto zodpovednosti
        - aby byla instance PrinterTemplateBuilder reentrantni, cini kroky navic - volani `reset`,
          na ktere se nesmi zapomenout
        - vznika coupling, nebot je kroky treba volat ve spravnem poradi
          - `parser.feed` -> `build` (resp. jeho prvni radek) -> reset (resp. vyprazdneni
            `_template_tokens`)
      - vsechny tyto problemy by se snadno vyresily, kdyby container, ktery uchovava zparsovane
        tokeny, byl implementovan jako oddelena struktura a pro kazdy parse by se vytvoril, pouzil
        a zahodil
        - bud muze byt spesl trida s metodou `add_token`, ktera bude kontrolovat rootovitost tokenu
          - parseru by se pak misto builderu predala instance teto kolekce (plus factory trida)
        - nebo muze byt prosty list, v tu chvili si parser muze ukladat i v sobe a mit reader, kterym
          se z nej vytahne po zavolani `feed`, builder by pak akorat post-factum zkontroloval, ze
          jsou vsechny tokeny rootove
          - mimochodem, tohle by sice cinilo instanci PrinterMarkupParser stavovou (coz neni uplne
            zahodno), ale ta uz ve skutecnosti stavova je - uklada stack, ktery se nikde neresetuje.
            sice by mel po zparsovani validni template byt prazdny, ale kdyz bude nevalidni, tak to
            neni zaruceno
        - ja bych byl pro prvni moznost, tedy instanciovat parser s referencemi na 1) one-off
          instanci "token collectoru", 2) instanci factory classy s `create_...` metodami
          - kdyby factory neposkytovaly tokenum printer_settings, tak by cela factory classa mohla
            byt staticka a nebylo by treba instanciovat a predavat parseru
          - porad si nejsem jist, ze ma kazdy token v celem strome ukladat printer_settings - podle
            me by se mel metode `render` explicitne predavat kontext (ktery by se pri stromovem
            volani vzdycky posilal niz, coz umoznuje i predavani dalsich veci relevantnich pro dany
            podstrom) a v nem printer_settings
          - mimochodem nektere veci, ktere se ted resi tak, ze nadrazeny token prenastavuje hodnoty
            podrizenemu (napr. nastavovani `cell.column`, nebo borderu columnum (coz teda nejsou
            tokeny per se)) by se dalo resit cisteji - pri volani renderu na cell by se proste v
            kontextu predaval aktualni column

- cely soubor bych rozsekal - obsahuje
  - konstanty - rozhodil bych do prislusnych casti
  - exception classy - ditto
  - enumy - ditto
  - utility funkce (number_to_parts) - ditto
  - strukturu PrinterSettings
    - nevim, jestli ma vubec co delat v package printer_markup
    - instanciuje se v danube.entities.CashRegister, takze bych asi i definoval tam
  - Formatter - tak trochu outlier - prevedl bych na nejaky WrappedToken base token
  - mixiny (TokenContainerMixin, BoldTokenMixin)
  - base tokeny (TemplateToken, SingleContentToken)
  - alignment tokeny (LeftAlignToken, CenterAlignToken, RightAlignToken, AlignTokenContainer)
  - line tokeny (LineToken, FilledLineToken, EmptyLineToken)
  - table tokeny (TableCellToken, TableHeaderCellToken, TableRowToken, TableHeaderToken, TableToken)
  - PrinterTemplateBuilder

=== danube.services.printer_markup.parser ===

- PrinterMarkupParser
  - konstanty
    - SINGLE_CONTENT_TAGS je definovana jako PRESERVE_CONTENT_TAGS.copy()
      - proc jsou na sobe tyhle seznamy zavisle?
      - pokud bude vzdycky platit, ze single content <=> preserve content, tak staci jedna konstanta
      - pokud nelze takto rict, tak at jsou nezavisle
      - navic je zvlastni, pouzivat u konstant .copy()
        - pokud hrozi, ze se budou menit, nemely by byt konstantami

  - nested type `TagData` s atributy `tag_name`, `content`, `attrs`
    - nevidim duvod pro suffix `Data`, navic nazev tagu bych uplne nenazyval daty
      - nazval bych proste `Tag`
    - prefix `tag_` u nazvu mi prijde nadbytecny - proc mam psat `tag_data.tag_name`, kdyz muzu
      napsat proste `tag.name`?

  - konstruktor
    - bere a ulozi referenci na builder (mel by byt pouze "visited tag collector", viz vyse)
    - inicializuje `self._stack` na []
      - ja bych mozna nazval `_tag_stack` pro uplnou presnost

  - property `current_tag_data` zpristupnuje vrchol stacku
    - zbavil bych se `_data` suffixu, stejne jako u nazvu typu - `current_tag_data` mi
      navozoval dojem, ze se zde postupne kumuluje content tagu, tedy ne nazev a attry
  - metoda `pop_stack`
    - `list.pop()` vraci posledni prvek, nevidim tedy duvod nejdriv volat `current_tag_data`
  - obe metody podle muzou byt private

  - `handle_data`
    - pokud jsou data neprazdna, nebo jde o `preserve_content_tag`, prida `data` do
      `current_tag.content`
      - trochu zvlastni je, ze v contentech `Tag`u se muze objevit jak `Token` tak raw text data
        - Token je struktura, ktera by ve vstupni sablone, nebo ji odpovidajicich strukturach
          (coz bych si myslel, ze je i tag stack) nemela vubec figurovat
        - na druhou stranu, kdyby nemela, tak se musi udelat dvoupruchodove - nejdriv zparsovat
          sablonu do tag stacku a ten pak depth-first projit a prevest na strukturu tokenu
        - asi je tedy takto jednodussi i efektivnejsi, jen si musi clovek zvyknout,
          ze current tag je smesici tagu a tokenu :)
  - `handle_endtag`
    - ze je stack prazdny se testuje pres `current_tag_data` property, coz mi prijde ponekud
      antiintuitivni, ale to je asi vec uhlu pohledu
    - prazdnost stacku a rootovitost tokenu se testuje jednou podminkou, pri nesplneni byt jedne ze
      stran spadne do else
      - to znamena, ze
        - pokud stack jeste neni prazdny, prida se token do contentu nadrazeneho tagu,
          i kdyz je ten aktualni rootovy
        - pokud je stack prazdny, ale token neni rootovy, snazi se ho pridat do
          current_token.content, coz podle me spadne chybou
  - `_create_token` ->
  - `_token_factory_for`
    - metoda se jmenuje `_token_factory_for`, ale dela o hodne vic, nez jeji nazev napovida,
      v podstate vetsina jeji logiky odpovida spis nazvu `_create_token`, ktera ji vola
    - navic metoda vraci tri veci, ktere spolu uzce souvisi
    - obecne je zvykem, kdyz se v kodu predavaji (at uz z funkce, nebo do funkce) grupy takhle
      provazanych dat, hledat abstrakci, ktera je spojuje a predavat misto nekolika jednotlivych
      hodnot instance abstraktnich objektu, ktere je obsahuji
    - tato abstrakce uz zde je - je ji Token
    - presto funkce misto aby vracela abstrakci, vraci jednotlivy niskourovnovy hodnoty
    - ano, je pravda, ze factory metody jsou dve, takze logika pro vytvoreni tokenu by se v nich
      musela duplikovat a nebo se musi extrahovat do jine funkce, ktere se ale zase budou muset
      predavat jednotlive hodnoty
      - prijde mi ale mensi zlo mit builder funkci, ktera bere jednotlive hodnoty a dela z nich
        kompozit, nez mit funkce, ktere delaji tunu veci, vraci x hodnot a caller si z nich musi
        kompozit poskladat
    - BTW, vytvoreni kompozitu (aktualne v `_create_token`) obnasi tri veci
      - zavolani `factory` s `factory_kwargs` - v duplikaci tohohle bych fakt problem nevidel
      - v cyklu pridat data do nove vznikleho tokenu
        - na to by mohl mit `TokenContainerMixin` metodu, ktera by pridavala data hromadne
          (mimochodem u TCM jsem navrhoval prejmenovani, nebot `data` povazuju za nicnerikajici a
          navic neni konzistentni se zbytkem (hlavne tridou SingleContentToken). kdyby se
          prejmenovalo na `self._contents`, tak muzou byt metody `add_content` a `add_contents`,
        - pak bude misto cyklu jedno volani metody
      - preklad z BuilderError na ParseError - na tohle byl myslim v nejakych utils obecny
        context manager, neco jako
        `with error_translation(BuilderError, ParseError): token.add_contents(token_contents)`
    - ja bych tedy byl pro nasledujici strukturu:
      - mit metody `_create_token` a `_create_line_token`, ktere budou v podstate delat to,
        co aktualne delaji metody `_token_factory_for` a `_line_token_factory` (klidne vcetne toho,
        ze prvni vola druhou)
      - z puvodnich call situ puvodniho `_create_token` volat novy `_create_token` - ty se tedy
        vlastne nezmeni
      - z novych `_create_token` a `_create_line_token` volat neco jako `_do_create_token`,
        ktere bude brat trojici, ktera se predtim vracela nahoru, a vracet token (tedy udela to,
        co delal puvodni `_create_token`) a vysledny token poslat nahoru
      - kod se tedy velmi nezmeni, ale dve urovne (priprava casti a vytvoreni kompozitu) si otoci
        pozice v ramci call stacku
      - vyhodou je, ze mame jednu jednoduchou metodu, jejimz ucelem je prave poskladat komponenty
        dohromady, nic dalsiho uz nevola a z jeji signatury je jasne, jake casti bere (zatimco
        navratova hodnota, kterou se trojice predava ted, zadnou signaturu nema a i kdyby mela,
        budou zde videt jen typy, nikoly koncepty)
  - `_line_token_factory`
    - obe by bud mely mit suffix `_for`, nebo ani jedna
    - vetsina vyresena v ramci `_token_factory_for`
    - neni mi uplne jasny cyklus, ktery odstranuje default alignment keys (to neznamena, ze je
      spatne, jen jsem ho nejspis nepochopil)
      - cekal bych, ze defaultni alignment je pro kazdy typ tagu prave jeden, proc se tedy
        odstranuji vsechny ALIGNMENT_KEYS?
- obecne k nazvum
  - zbavil bych se naproste vetsiny `data`
    - jedine, kde bych asi nechal, je parametr `data` v `handle_data`
    - TagData -> Tag
      - uz jsem psal vys
      - spolu s tim vsechny `*tag_data` promenne a parametry
      - TagData.tag_name -> Tag.name
      - TagData.content -> Tag.contents - je to list
    - token_data -> token_contents
      - spolu s prejmenovanim TokenContainerMixin._data na ._contents, .add_content(s),
        .validate_content, atd.
      - v tu chvili by vyse zminena fce `_do_create_token` vypadala takto:
        @staticmethod
        def _do_create_token(factory, factory_kwargs, contents):
          token = factory(**factory_kwargs)

          with error_translation(BuilderError, ParseError):
            token.add_contents(contents)

          return token
      - navic mi prijde logictejsi
        contents = tag.contents.copy()
        nez aktualni
        token_data = tag_data.content.copy()
