=== Tue, 18.3. ===

- prace - alto
  - 11.30-12.30 - predelani feature testu vsech moznych alternativ vztahu
    klienta a jidelen na testy ClientAuth, feature test testuje jen zakladni
    funkcnost formulare
  - 5-7.30,7.45-8.15 - hrani s SQL - snaha prijit na efektnivni (a activerecordem
    podporovany) zpusob, jak ziskat neprime vztahy klientu a jidelen
  - 8.15-9
    - refactored Client#all_canteen_relations, removed duplicates
      ClientRelation renamed to CanteenRelation
    - provided potentially more efficient alternative default_scope to ClientCant
    - removed unused methods from BootstrapHelper and Meal
    + rucni testovani
  - 9.30-10 - analyza efektivity nacitani neprimych jidelen klienta
  - 0.30-1.30 - pridani eagel loadingu, revize efektivity
  = 6h15

  def self.select_all_sanitized(query,*args)
    sanitized_query = sanitize_sql_array([query,*args])
    connection.select_all(sanitized_query)
  end

  def select_all(query,*args)
    self.class.select_all_sanitized(query,*args)
  end

  CanteenRelation = Struct.new(:id,:name,:type)
  def indirect_canteen_relations
    query = "SELECT jidelna_firma_key,firma.firma_id,client_firma_join.typ" \
      " FROM client_firma_join,jidelna_retezec_join,firma" \
      " WHERE client_key = ?" \
      " AND retezec_firma_key = firma_key" \
      " AND firma.id = jidelna_firma_key"
    # returns array of rows, each row is [canteen_id,canteen_name,relation.typ]
    select_all(query,id).rows.map do |(id,name,type)|
      CanteenRelation.new(id,name,PortionsPolicy.shortcut_to_name(type))
    end
  end

- for custom SQL in activerecord, we can use either Model.find_by_sql, which
  converts results to instances of Model, or Model.select_all, which returns
  array of hashes



- přímé jídelny klienta + typ vztahu:
SELECT firma_key,typ FROM client_firma_join
  WHERE client_key = {client.id}
  AND firma_key IN (SELECT id FROM firma WHERE typ = 'J')

nebo

SELECT firma_key,client_firma_join.typ FROM client_firma_join,firma
  WHERE client_key = {client.id}
  AND firma_key = firma.id
  AND firma.typ = 'J'

- je rychlejsi podminka firma_key IN (podselect na id jidelen) nebo join s
  tabulkou firem a podminka na typ firmy primo na nem?
- přímé řetězce klienta + typ vztahu - totéž, ale 'R' misto 'J'
- všechny AND by odpadly, kdyby byly client_jidelna_join a client_retezec_join
  odděleny

- nepřímé jídelny klienta (přes řetězec) + typ vztahu:
- OMEZENI NA RETEZCE NENI TREBA SPECIFIKOVAT, NEBOT POROVNAVAME
  firma_key = retezec_firma_key, pricemz v retezec_firma_key by se mely
  vyskytovat pouze id retezcu
SELECT jidelna_firma_key,typ FROM client_firma_join,retezec_jidelna_join
  WHERE client_key = {client.id}
  AND firma_key = retezec_firma_key
  AND firma_key IN (SELECT id FROM firma WHERE typ = 'R')       | odpadlo by

nebo

SELECT jidelna_firma_key,client_firma_join.typ FROM client_firma_join,retezec_jidelna_join,firma
  WHERE client_key = {client.id}
  AND firma_key = retezec_firma_key
  AND firma.id = retezec_firma_key                              | odpadlo by
  AND firma.typ = 'R'                                           |

- při každém requestu na stránku, která obsahuje select jídelen (menu) dělám
  UNION z přímých a nepřímých (přes řetězec) jídelen klienta

connection.select_all("SELECT jidelna_firma_key,client_firma_join.typ FROM client_firma_join,jidelna_retezec_join,firma" \
  " WHERE client_key = ?" \
  " AND firma_key = retezec_firma_key" \
  " AND firma.id = retezec_firma_key" \
  " AND firma.typ = 'R'", client.id)
