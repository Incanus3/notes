=== prvotni poznamky ===

- v ramci reimplementace plneni qStore jsem narazil na problem s tim, ze po updatu (ktery projde -
  overeno v h2-console) crnk endpoint pro seznam kapabilit stale vraci stare udaje, toto se
  mimochodem delo i v puvodni implementaci
- v ramci tracovani zjisteno, ze v hibernate-core/org/hibernate/loader/Loader.processResultSet
  dostane spravny ResultSet (rs.delegate.result.rows maji novou hodnotu), ale results list vraceny z
  getRowsFromResultSet obsahuje starou hodnotu
- v teze classe se s kazdym zaznamem z ResultSetu vola getRow, ktery v cyklu (krom jineho) vola
  session.getEntityUsingInterceptor() ten vrati object, ktery uz ma stare hodnoty, coz i odpovida
  tomu, ze pokud tohle volani vrati object, tak se vola metoda instanceAlreadyLoaded, ktera ma
  komentar "the entity instance is already in the session cache"
- session.getEntityUsingInterceptor jednoduse zavola persistenceContext.getEntity(key) coz proste
  vrati stary objekt z entity mapy (persistenceContext je zde StatefulPersistenceContext)
  - session se sem dostane shora skrze tunu metod, zacina to ale v AbstractProducedQuery.doList, kde
    se vola `getProducer()`, coz vrati evidetne instanci `SessionImpl` a na tu se pak zavola
    `.list()`, ten pak vola `HQLQueryPlan.perfromList()`, kteremu jako session preda `this` a ta se
    pak predava niz a niz
  - AbstractProducedQuery.getProducer proste vrati ulozeny producer (coz je
    SharedSessionContractImplementor), ktery se uklada v konstruktoru, odkud tedy prisel?
    - CriteriaQueryTypeQueryAdapter.getResultList() vola jpqlQuery.getResultList(), coz posleze vola
      kod popsany vyse
    - jpqlQuery je ulozeny QueryImplementor, ktery se opet nastavuje v konstruktoru
      - btw na jpqlQuery se zde deleguji skoro vsechny metody
    - AbstractProducedQuery.getResultList() se (dynamicky) vola z
      SharedEntityManagerCreator.DeferredQueryInvocationHandler.invoke()
      (radek 406) na this.target (coz je typu Query)
      - this.target se opet nastavuje v konstruktoru
    - JpaQueryExecution.doExecute (coz posleze vola AbstractProducedQuery.getResultList()) nejdriv
      vola query.createQuery(), kde query prisla shora, ale createQuery vytvari novou
      - PartTreeJpaQuery.doCreateQuery() vola this.query.createQuery(), ma teda uz nejakou query
        ulozenou (mimochodem taky uklada em)
        - this.query se nastavuje v konstructoru na PartTreeJpaQuery.QueryPreparer(recreationRequired)
        - tohle bych tracoval v dalsim pruchodu, protoze ted uz jsme zastavili pozde
    - v JpaQueryExecution.doExecute ma ale query ulozene em, coz je Proxy138@22501 nad
      SharedEntityManagerCreator$SharedEntityManagerInvocationHandler@22517
    - v CriteriaQueryTypeQueryAdapter.getResultList je jpqlQuery, ktery ma jako producer
      SessionImpl@17828, ktera je pak vsude nize ve stacku a tutez SessionImpl ma
      CriteriaQueryTypeQueryAdapter jako this.entityManager
    - v SharedEntityManagerCreator$DeferredQueryInvocationHandler.invoke je entityManager proxy nad
      ExtendedEntityManagerCreator$ExtendedEntityManagerInvocationHandler, ktery ma ovsem jako
      target tutez session (so far so good)
    - v JpaQueryExecution$CollectionExecution.doExecute (o stack frame vys) uz neni videt session,
      nybrz je tam puvodni query (PartTreeJpaQuery), ktera ma jako em proxy nad
      SharedEntityManagerCreator$SharedEntityManagerInvocationHandler, ktery ma jako targetFactory
      proxy nad LocalContainerEntityManagerFactoryBean, coz bude ta, kterou nastavujeme v
      persistence configuration, vypada to tedy, ze tady to vsechno zacina
    - bohuzel cely tenhle trace jsem delal pro volani, ktere cte capabilities z CapabilityManageru
      (EA), snad to ale bude podobne pro volani z crnku

- napadaji me tedy dva problemy, ktere tu jsou
  - crnk endpoint, ktery vraci seznam capabilit by nemel reusovat existujici
    StatefulPersistenceContext, nebo
  - endpoint, ktery zapisuje update slotu, by mel zajistit, aby se propsalo do tohoto persistence
    contextu (coz bych teda cekal, ze by se melo zajistit samo)
- podivne taky je, ze tohle reusovani resultu z entity mapy se deje az po provedeni dotazu - dotaz
  na db (ktery by mel byt to, co muze trvat dlouho) uz se stejne provedl, ale resulty se zahodi,
  pokud existuji odpovidajici zaznamy v entity mape
- cele tohle na me pusobi tak, ze je problem v samotne konfiguraci persistence contextu, konkretne
  ze se reusuje entityManager (a tudiz session), ktery by mel byt per request
- z komentare nad implementaci StatefulPersistenceContextu:

A <strong>stateful</strong> implementation of the {@link PersistenceContext} contract meaning that
we maintain this state throughout the life of the persistence context.

IMPL NOTE: There is meant to be a one-to-one correspondence between a {@link
org.hibernate.internal.SessionImpl} and a PersistentContext.  Event listeners and other Session
collaborators then use the PersistentContext to drive their processing.

- metody StatefulPersistenceContextu, ktere by mohly byt pouzitelne pro vycisteni kontextu (i kdyz
  mozna by se spis melo resit na urovni session, aby si otevrela novy kontext):
  - removeEntity
- veci v SessionImpl, ktere by mohly byt uzitecne pro cisteni persistence contextu:
  - metody - clear cleanupOnClose (ta vola persistenceContext.clear(), odkud se ale vola ta?)
  - atributy - autoClear autoClose (berou se z options, ktere SessionImpl dostane v konstruktoru,
    nebo se daji nastavit pres setAutoClear , pokud je autoClear = true , pak se v
    afterTransactionCompletion zavola internalClear
  - pokud je autoClose = true , pak se v afterCompletion transaction observeru zavola managedClose ,
    coz posleze zavola super.close() (vola AbstractSharedSessionContract.close(), ten uz ale necisty
    persistenceContext)

=== debugovani problemu s tim, ze crnk vraci stara data ===

- pri snaze napsat na to integracni test jsem narazil na problem, ze
  repository.create(capabilityListRow) pada, protoze nejdriv persistuje record, pak se ho snazi
  skrze findOne znovu najit a neuspeje
- prvni misto, kde se prejde z crnku do hibernate je call
  JpaEntityRepositoryBase.saveInternal() -> SessionImpl.persist()
  - SessionImpl krom jineho obsahuje
    - actionQueue
    - persistenceContext (coz je v tomto pripade StatefulPersistenceContext)
    - factory (SessionFactoryImpl)
    - jdbcConnectionAccess (ten ma dale connectionProvider a ten ma dataSource, coz je v tomto
      pripade HikariDataSource, ktery ma krom jineho jdbcUrl, coz spravne identifikuje indexdb)
    - jdbcCoordinator
    - currentHibernateTransaction = null
    - transactionCoordinator
    - cacheTransactionSync (NoCachingTransactionSynchronizationImpl)
    - isTransactionCoordinatorShared = false
    - flushMode = AUTO
    - autoJoinTransactions = true
    - cacheMode = NORMAL
    - sessionEventsManager s jednim listenerem
- v ramci em.persist(CLR) se dostane do DefaultPersistEventListener.onPersist, kde se na SessionImpl
  vola .getPersitenceContextInternal(), coz vrati instanci StatefulPersistenceContext@20325, kde
  session = SessionImpl@20295 a entityEntryContext = EntityEntryContext@20483
- na tohle se pak vola .getEntry(), coz by melo vratit asociovany zaznam EntityEntry, pokud je
  entity ManagedEntity (coz je nejaka chytra forma entity, ktera vi, s jakou session, prip. entity
  managerem je svazana), v nasem pripade ale neni, takze vrati null
- nasledne se vola (skrze dalsi metody) AbstractSaveEventListener.saveWithGeneratedId, ktery vola
  SessionImpl.getEntityPersister(), coz vola
  getFactory().getMetamodel().entityPersister(entityName).getSubclassEntityPersister(object, getFactory())
  pricemz
  - getFactory() vrati SessionFactoryImpl s obrovskou spoustou vlastnosti vcetne
    cacheAccess = DisabledCaching, currentSessionContext = null, synchronizationType = null
    a persistentContextType = null
  - entityPersister() vrati SingleTableEntityPersister pro CLR s tunou vlastnosti vcetne
    canReadFromCache = false, canWriteToCache = false, invalidateCache = false
- nasledne se (skrze dalsi metody) vola AbstractSaveEventListener.performSaveOrReplicate, kde se
  krom jineho vola SessionImpl.isTransactionInProgress, kde bychom se mohli dozvedet, co se pouziva
  na synchronizaci transakci. z toho se mi ale povedlo vyskocit, tak snad priste
  - aha, do getTransactionDriverControl se tu ani neskoci, protoze pred && je isJoined(), coz vrati
    false
- krom jineho vola AbstractSaveEventListener.addInsertAction, coz vytvori EntityInsertAction a prida
  ji do SessionImpl.getActionQueue, tedy by teoreticky mohl find taky hledat
- pokud jsem neco neprehledl, tak tohle je posledni realna vec, co se udela, tudiz insert action se
  jenom pridala do nejake fronty, ale nevim jak se docililo toho, aby se realne provedla, coz by
  sice vysvetlovalo, proc se pak nenajde, ale pak by to nefungovalo nikdy, coz ale v druhem testu
  funguje
  - ani pri druhem stepovani se mi nepodarilo prijit na to, kde se provadi samotny zapis
  - navic pokud po navratu z volani em.persist() zkusim vyhodnotit expression em.refresh(entity),
    tak rve, ze entita v db neni (prestoze find() a contains() vraci uspesne, ale nejspis jen
    in-memory vysledky)

- v naslednem volani findOne se kod dostane do AbstractProducedQuery.list(), kde se vola .doList(),
  ktery ale vyhodi HibernateException s messagi "could not prepare statement" a causem
  JdbcSQLSyntaxException s messagi "table CAPABILITY_LIST not found"
  - nevim, jestli to ale nemuze souviset s tim, ze HikariPool hlasi thread starvation, mozna proto,
    ze tracovani trvalo moc dlouho a mezitim se nejak prerusilo spojeni

- mimochodem stejne volani repository.create v CapabilityListRowJpaRepositoryTests projde s tim, ze
  tenhle test se lisi ve dvou vecech:
  - v ContextConfiguration loaduje cely QwazarKB
  - je to @DataJpaTest, takze mozna ma nejak preplacly entity manager, transaction runner, apod.
- kdyz v CapabilityUpdateIntegrationTest pouziju QwazarKB, pada porad na stejne chybe, takze
  CapabilityListRowJpaRepositoryTests funguje nejspis prave diky @DataJpaTest, coz je dobre, protoze
  to znamena, ze CapabilityUpdateIntegrationTest je bliz produkcnimu prostredi
  - kdyz volam repository.create() z CapabilityUpdateIntegrationTest, em je proxy nad
    ExtendedEntityManagerCreator, ktery pak vola invoke na SessionImpl
    - SessionImpl.currentHibernateTransaction je celou dobu null
    - v AbstractSaveEventListener.performSaveOrReplicate je inTrx pochopitelne false
  - kdyz ale volam repository.create() z CapabilityListRowJpaRepositoryTests, tak em je proxy nad
    SharedEntityManagerCreator, ten pak ale vola invoke taky na SessionImpl, persistenceContext je
    opet StatefulPersistenceContext
    - SessionImpl.currentHibernateTransaction je uz na zacatku instance TransactionImpl
    - SessionImpl.transactionCoordinator je JdbcResourceLocalTCImpl
    - v AbstractSaveEventListener.performSaveOrReplicate je inTrx pochopitelne true
- chvili jsem si myslel, ze samotny zapis do db se neprovede ani v jednom pripade, ze se vzdy zapise
  jen EntityEntry do entity manageru, resp. EntityEntryContext a pak se z nej zase vytahne a rozdil
  je v tom, ze v pripade CapabilityListRowJpaRepositoryTests probehne oboji v ramci jedne transakce,
  takze jde o tentyz EntityEntryContext a tudiz se v nem najde
- vypada to ale, ze v pripade CapabilityListRowJpaRepositoryTests se data skutecne vytahnou az z db
- porad mi ale neni jasne, kde k samotnemu zapisu dojde - vystopoval jsem jen pridani do EM a EEC +
  pridani insertu do ActionQueue, ale samotny zapis ne


- v CapabilityUpdateIntegrationTest se z nejakeho duvodu crnk request neobsluhuje skrze CrnkServlet,
  nybrz skrze CrnkFilter volany primo z apache.catalina.core.ApplicationFilterChain.internalDoFilter
- transakce se v crnku vytvari ve filtru, ktery se registruje v JpaModule.setupTransactionManagement
  a vola se z JsonApiRequestProcessor.processAsync -> DocumentFilterChainImpl.doFilter (ten prochazi
  vsechny filtry, ktere se v podstate chovaji jako middleware)
- TransactionRunner.doInTransaction vytvori TransactionTemplate a zavola na nej template.execute,
  coz posleze vola AbstractPlatformTransactionManager.getTransaction a .startTransaction
- to posleze vola JpaTransactionManager.doBegin a createTransactionManagerForTransaction, coz vede
  az k inicializaci SessionImpl
- je ovsem otazka, zda se toto nedeje jenom pri prvnim volani tohohle TransactionRunneru
  - nene, session se vytvari pri kazdem volani transactionRunner.doInTransaction, coz je super,
    ovsem nevysvetluje to, jak je mozne, ze mezi requesty zustavaji objekty v identity mapu
- zkusil bych tedy pouzit pro crnk nas TransactionRunner a do nej vlozit breakpoint (aby nam nestalo
  na vsech transakcich springu)



== prubezne summary problemu ==

- pokud se do indexdb zapisuje skrze necrnkove repozitare, crnkove repozitare zmeny nevidi, a to ani
  ve chvili, kdy se zapis obali volanim transactionRunner.doInTransaction(), coz je crnkova vec,
  ktera se pouziva kolem kazdeho crnkoveho requestu a mela by vytvaret novou session, coz jsem
  otestovat pridanim preakpointu do konstructoru SessionImpl v ramci testu, ktery dvakrat vola
  endpoint
- pokud se do db zapisuje skrze crnkove repozitare
  a) bez transakce
  - pada na tom, ze persist sice projde, ale findOne (ktery se vola v ramci
    JpaEntityRepositoryBase.saveInternal) vysledky nevidi
  b) s transakci runce pres repository.entityManager.transaction.begin() a .commit()
  - samo o sobe funguje a repozitare i endpointy (volane testem ve stejnem procesu, proti plne
    pustenemu serveru jeste netestovano) zmeny vidi, pada ale potom pri updatu, protoze session se
    neukonci a tudiz pak rve, ze se snazime persistovat novou instanci s id, ktere uz v session je
  c) s transakci skrze transactionRunner.doInTransaction()
  - oped pada na findOne v ramci JpaEntityRepositoryBase.saveInternal
- moc mi neni jasny, jak to muze takhle fungovat, protoze
  - bud bych cekal, ze transactionRunner.doInTransaction vytvori session a cely zbytek crnku nejak
    nastavi tak, aby entity managery, se kterymi se pracuje (tedy typicky ty vracene z
    JpaModule.getEntityManager) byly svazane s touto transakci
    - pak ovsem nevim, proc by mel selhat nasledny findOne v JpaEntityRepositoryBase.saveInternal,
      kdyz cele volani repository.create bezi v jednom doInTransaction bloku
  - nebo entity managery s touto transakci svazane nejsou, pak ale nevim, jak ale kdy muze create
    fungovat, coz pokud vim, tak pri pocatecnim testovani pomoci httpie proti bezicimu QwazarKB
    fungovalo
  - navic nechapu, ze pokud doInTransaction obaluje kazdy request a vytvari novou session, jak v ni
    muzou zustavat stara data

- zkusil bych ted chvili misto skrze testy testovat zase http klientem proti bezicimu qwazaru a
  pokusit se (s nove nabytymi znalostmi) znova zjistit, jak je to s vytvarenim sessiony a podivnym
  sdilenim entity mapy


== TODO ==

[ ] sepsat poradne dosavadni zjisteni
[ ] zjistit, odkud presne se bere session a jak se tam dostane
- odkud v podstate vime, ale jeste neni uplne jasne, kde se tam vezme
[ ] procist si poradne JpaModule a s nim souvisejici kod

== Spring materialy ==

https://stackoverflow.com/questions/21038706/persistenceunit-vs-persistencecontext/21038785
https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#orm-jpa-tx
https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#tx-propagation
https://www.baeldung.com/hibernate-entitymanager
https://www.baeldung.com/jpa-hibernate-persistence-context
https://www.baeldung.com/spring-transactional-propagation-isolation
https://www.baeldung.com/spring-data-jpa-multiple-databases
https://docs.jboss.org/hibernate/core/3.3/reference/en/html/transactions.html#transactions-connection-release
https://developer.jboss.org/docs/DOC-13951
https://docs.spring.io/spring-framework/docs/3.0.0.M3/reference/html/ch14s02.html
https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/EnableTransactionManagement.html
https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/TransactionManagementConfigurer.html
https://www.doanduyhai.com/blog/?p=95
https://www.doanduyhai.com/blog/?p=222

https://www.baeldung.com/jpa-join-types
https://www.baeldung.com/spring-data-jpa-named-entity-graphs
https://www.baeldung.com/spring-open-session-in-view
https://www.baeldung.com/integration-testing-in-spring

https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing
https://docs.spring.io/spring-framework/docs/5.3.13/reference/html/testing.html#testcontext-tx
https://site.mockito.org/
https://www.toptal.com/java/a-guide-to-everyday-mockito
https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html
https://github.com/mockito/mockito/wiki/Mockito-vs-EasyMock
https://github.com/powermock/powermock
https://reflectoring.io/spring-boot-testconfiguration/
https://www.baeldung.com/spring-security-integration-tests

https://www.baeldung.com/kotlin/delegated-properties
