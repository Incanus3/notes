=== 29.7. ===

- PayService.print_bill vytvari record v sk_fis
  - bud pridat fkey na novy model eet_transaction/result/?, pak ale musi food vzdy zajistit
    pritomnost sloupce
  - nebo pridat foodie-managed model, ktery zastresuje cz i sk fiskal a ma fkey na sk_fis i
    eet_transaction
- odkud brat dic?
- jak resit vat?
- travel_services?
- deposit, withdraw?


- SK Jakub tvrdi, ze SQL procedura to_sk zapise fiskal kody do sk__plt, ale to_sk se vola ze save_sk
  a save_sk se vola pred print_bill, tudiz kody jeste nejsou



== problemy branici rozumnemu prepinani fiskal implementace ==

- FiskalClient je prilis nizkourovnovy a odrazi konkretni routy SK fiskal modulu
  - to samo o sobe nevadi, ale musi nad nim byt vysokourovnovejsi wrapper s obecnym api,
    ktere dava smysl napric variantami
  - tak je nejspis zamyslena nova trida FiskalService, kterou backbone nove pridalo jako
    prostrednika mezi zbytkem kodu a FiskalClientem, coz je logicky krok
  - vzhledem k tomu, ze v dobe jejiho pridani uz byly mergnuty CZ zmeny s alternativni variantou
    FiskalClient, mohli slovensti bratia aspon napsat, ze k takove nekompatibilni zmene,
    jejimz vysledkem je uplne obejiti drive pridane CZ varianty, doslo
- pokud je FiskalService skutecne zamyslena jako wrapper, ktery by mel zbytek kodu odstinit od
  rozdilu mezi jednotlivymi fiskal moduly/implementacemi, je to chvalyhodne, ale realita tak
  bohuzel nevypada, viz dale
- verejne metody FiskalService se temer 1:1 mapuji na metody FiskalClient, tudiz o obecnejsim,
  vysokourovnovejsim api nelze hovorit
- FiskalService se vola z danube.services.pay.PayService a danube.views.closures
  - neni zadna ClosureService, veskera logika uzaverek je primo ve views, takze nelze rozumne
    unit-testovat, je treba sestavovat cele HTTP requesty a parsovat responsy, coz je navic radove
    pomalejsi, jak co se tyce rychlosti testu, tak jejich programovani
- PayService i closures views kazdou chvili podminkujou na zaklade fiskal_service.fiskal_type,
  coz by melo byt odstineno uvnitr FiskalService
  - diky tomuto nestaci overridovat FiskalService, ale je treba zasahovat jak do PayService,
    tak do closures VIEWS!
    - nemuve o tom, ze jak PayService, tak closures views jsou napsane priserne - minimalne
      dlouhatanske extremne neprehledne metody, zatim jsme ani nezvladli plne procist, nejhezcim
      prikladem je 480radkova metoda _prepare_payment_structures, jinak bezne kolem 100 radku (btw
      spousta code quality nastroju rve pri metodach nad 10 radku, do 30-50 bych jeste v nekterych
      pripadech prezil, ale musi byt aspon rozumne strukturovane a citelne)
    - nevim ale, kolik z toho jsou jeste stare Patrikoviny
- FiskalService by mela mit subclass pro jednotlive typy fiskalnich modulu/reseni
  - v aktualni implementaci je jedna trida FiskalService se spoustou ifu, coz znamena, ze pokud bude
    typu pribyvat (coz se deje), bude trida rust v nerozlustitelny chaos podminek (coz uz se pomalu
    deje taky)
  - kdyby bylo navrzene jako hierarchie trid, muze mit vetsina metod defaultni implementaci, kterou
    subclassy overriduji jen v pripade potreby (coz resi i stavove metody, viz dale)
  - navic pokud jsou si nektere moduly velmi podobne (z kodu usuzuju, ze minimalne AXIS a DATAPAC
    jsou), muze byt spolecna mezitrida pro obe a z ni pak dve deti doladujici posledni drobne rozdily
- FiskalClient a tudiz i FiskalService dela (z nutnosti) minimalne dve veci zaroven - fiskalizuje a
  tiskne ucty
  - to je bohuzel dano tim, ze nektere HW moduly se chovaji jako blackbox, ktery dela oboji, takze
    nejde na urovni klienta dost dobre oddelit
  - pri navrhu klienta se ovsem musi pocitat s tim, ze jina reseni (mimo jine ceske EET) nedela
    oboji dohromady
    - cekal bych tedy, ze wrapper trida FiskalService bude mit metody jak pro fiskalizaci, tak pro tisk
      uctu s tim, ze u implementaci, kde se deje oboji zaroven, budou proste jedny z nich prazdne
    - aktualni implementace takova ovsem neni - ma pouze metody pro tisk uctu, u kterych se drive
      tise predpokladalo, ze soucasne fiskalizuji, posleze se do nich dobastlila podminka
      if platba.get('typ', 0), ktera rika, ze pokud je typ nastaven a nenulovy, jedna se o fiskalni
      platbu a tudiz se tise fiskalizuje, aniz by o tom signatury api neco vypovidaly
- metody FiskalService (ktere se primo mapuji na metody FiskalClient) bych rozdelil do 4 skupin
  - veci souvisejici s jednotlivymi ucty - print_paragon, print_text (vubec se nevola), deposit,
    withdraw, reprint
  - veci souvisejici s uzaverkami (status, current_fiskal_day, end_of_day_time, x_closure,
    z_closure, interval_closure, reprint_closure
  - setupy - set_time, reset, confirm_message, paragon_copy, paragon_unsent, get_params_main,
    patch_params_main
  - get_next_bill_id - naprosta prisernost

  - v idealnim pripade by mely byt ucty/uzaverky/setupy od sebe oddeleny
  - jak se ale zda (alespon z kodu), jsou nektere fiskalni moduly/implementace stavove
    - kasa je informuje o uzaverkach/setupech a ty se pak projevi pri dalsich volanich
  - pokud to tak je, je pripustne, ze jsou tyto veci v jedne tride, pak bych ale predpokladal, ze
    bude existovat superclass ktera bude stavove metody (uzaverky/setupy) implementovat jako
    prazdne, aby implementace nestavovych modulu nemusely resit)
- metode fiskal_client.paragon_send se pri fiskalni platbe predavaji strukturovana data, ale pri
  nefiskalni se predava rovnou cely ucet ve stringu, s cimz posleze tise pocita interni metoda
  _perform_request, pokud je method = RAW
  - tento pristup je naprosto neoverridovatelny - tezko budeme ze strigoveho uctu znova parsovat
    a skladat data - nemluve o tom, ze to takhle vubec nekdo muze navrhnout
  - pokud nam staci pro CZ variantu overridovat jen FiskalService a FiskalClient nas nemusi zajimat,
    tak nas to tak moc nestve, ale i tak je to des
- priserne nazvy - x_closure? z_closure? aspon comment?
- FiskalService.get_next_bill_id
  - prestoze neni znacena jako interni, vola se jen interne a to v konstruktoru, vedlejsim efektem
    je, ze nastavi self.next_bill_id, ke kteremu ovsem nepristupuje interne, ale zvenci a to primo v
    denube.views.pay.quick_pay, .cancel, .deposit a PayDetail.put, aby se nasledne predalo PayService,
    ktera si ulozi a pozdeji pouzije
  - tedy 1) views (ktere o tom idealne nemaji vubec nic vedet) sahaji o 2 vrstvy niz, aby se
    dotazaly FiskalService o next_bill_id, ktere pak predaji o vrstvu niz PayService (proc se na
    FiskalService.next_bill_id nedotazuje primo PayService, ktera jinak tvori prostrednika mezi
    temito dvema kusy kodu, je mi fakt zahadou)
  - a 2) nastaveni FiskalService.next_bill_id je tichym vedlejsim efektem jejiho konstruktoru, na
    ktery se spoleha v uplne jinych mistech kodu

== problemy nesouvisejici primo s fiskalem ==

- danove sazby jsou zadratovany primo v kodu, misto aby byly v DB, nebo aspon v settings, a to
  dokonce na nekolika mistech a pokazde jinak reprezentovane
  - min. fiskal.services.fiskal_service radky 235, 378 a 456 (tam se jeste odvozuji z nejakeho
    typ_prirazky A/B), coz by me fakt zajimalo, jak bude aplikovatelne u nas
- FiskalClient._perform_request pri chybe neuzavre socket - melo by byt v try/finally
- minimalne v novem fiskal kodu (zbytek jsme moc nezkoumali) chybi u stringu markery pro preklad
- o spouste dalsich zverstvech v PayService ani radsi nezacinat

== testy ==

- aktualni kod ma naprosto minimalni test suite (existuje par yaml testu, vzdy jeden na kazdou z nekolika
  malo vybranych rout, ktere testuji v podstate jen format odpovedi, bez testovani jakekoli logiky),
  takze je (zvlast v kombinaci s implementaci, kterou rozhodne nelze nazvat self-explaining) velmi
  tezke, aby v kodu delal jakekoli zmeny nekdo, kdo ho dukladne nezna, protoze nelze dohlednout,
  kde vsude muze neco rozbit
- navic zacit psat testy neni pri tom, jakym zpusobem je resena inicializace db schematu, uplne jednoduchy
  - bezne se pocita s tim, ze se kompletni db schema vytvori migracemi, test runner vzdy vychazi z
    prazdne db, kterou si zmigruje a pak pousti testy v transakcich
  - tady jsou migrace jen na cast tabulek, cast se vytvari sql, resp. bash skripty (ktere loaduji ty
    sql a to jeste k tomu v nedeterministickem poradi, nez jsem opravil), cast se proste
    predpoklada, ze vytvoril food

== volani FiskalService ==

- print_paragon      - z PayService.print_bill
- print_text         - vubec (tady bych jeste pochopil, kdyby byly data jako string)
- deposit            - z PayService.print_bill, pokud nejsou fiscal_data, nybrz deposit_data a amount > 0
                     - zajimave je, ze PayService.deposit() volane z deposit view, resp .create_deposti()
                       vubec FiskalService.deposit nevola
- withdraw           - PayService.print_bill pokud jsou deposit_data a amount < 0
- reprint            - z PayService.reprint_bill (volano z PayService.finish, pokud bill_copies > 0)
                     - primo z views.pay.reprint! - za nejakych podminek vola PayService.reprint, za
                       jinych vola primo FiskalService.reprint - tohle view vubec nema vedet!

- status, current_fiskal_day, end_of_day_time, x_closure, z_closure - z danube.views.closures.ClosureList.get
- interval_closure   - z danube.views.closures.ClosureList._interval_closure <- .get
- reprint_closure    - z danube.views.closures.ClosureDetail.get

- set_time, reset, confirm_message, paragon_copy, paragon_unsent, get_params_main, patch_params_main
  - z danube.views.fiskal_conf.SetTime (proc tyhle views nejsou v appce fiskal?)

- get_next_bill_id - popsano rovnou ve stiznostech
